---
banner_image: media/banner.png
tags: [ci, cd, devops, fundamentos, cicd]
toc: true
extra:
  math: true
  mermaid: true
  mermaid_theme: default
---

# Day-03 | Garantia de Qualidade â€” O CoraÃ§Ã£o do CI

---

## ğŸ“Œ Objetivos de Aprendizado

- Entender por que qualidade Ã© essencial no fluxo de desenvolvimento    
- Compreender a lÃ³gica daÂ **pirÃ¢mide de testes**Â e como ela guia a automaÃ§Ã£o    
- Conhecer o conceito deÂ **"fail fast"**Â e como ele evita desperdÃ­cios    
- Reconhecer a importÃ¢ncia dosÂ **testes nÃ£o-funcionais**Â (performance, seguranÃ§a, usabilidade) 
- Explorar osÂ **steps de qualidade em um pipeline CI/CD**    
- Desenvolver consciÃªncia de que qualidade nÃ£o Ã© responsabilidade de um papel especÃ­fico, mas deÂ **todo o time** 

---
## ğŸ—ï¸ Por que a Qualidade Ã© o CoraÃ§Ã£o do CI?

AÂ **IntegraÃ§Ã£o ContÃ­nua (CI)**Â Ã© o motor do desenvolvimento moderno.  
Ela garante que cada mudanÃ§a no cÃ³digo flua rapidamente para o repositÃ³rio principal.

Mas pense assim:Â **nÃ£o adianta rodar rÃ¡pido se o combustÃ­vel Ã© ruim**.  
Se o cÃ³digo que entra no pipeline nÃ£o tem qualidade, todo o resto da esteira perde o sentido.

ğŸ’¡Â **Sem qualidade:**

- Cada commit vira uma loteria    
- Defeitos se acumulam e explodem em fases tardias    
- O time perde confianÃ§a no produto    

ğŸ‘‰Â **ConclusÃ£o:**Â qualidade nÃ£o Ã© "extra", Ã© parte central do CI.

---
## ğŸ§ª A PirÃ¢mide de Testes

### O que Ã© a PirÃ¢mide de Testes?

A PirÃ¢mide de Testes Ã© um modelo visual que nos ajuda aÂ **equilibrar esforÃ§o, custo e eficiÃªncia**Â na hora de testar um software. Ela ilustra a quantidade ideal de cada tipo de teste que devemos ter, guiando-nos para investir nosso tempo e recursos de forma inteligente.

![](./media/course/assets/piramede_tests.png)

### Entendendo Cada Camada

#### 1.Â **Base: Testes UnitÃ¡rios (Muitos!)**

SÃ£o a fundaÃ§Ã£o sÃ³lida e ampla da pirÃ¢mide. Eles testam as menores unidades de cÃ³digo (funÃ§Ãµes, mÃ©todos ou classes) de formaÂ **completamente isolada**Â (usandoÂ _mocks_Â eÂ _stubs_Â para dependÃªncias externas).

- **Objetivo:**Â Verificar a lÃ³gica interna e o correto funcionamento de cada "tijolo" individual do sistema
    
- **CaracterÃ­sticas:**Â SÃ£oÂ **extremamente rÃ¡pidos**Â (milissegundos por teste),Â **baratos**Â de criar e manter, e fornecemÂ **feedback imediato**Â aos desenvolvedores. Por isso, devem ser a categoria mais numerosa
    
- **Exemplo:**Â Testar uma funÃ§Ã£o que calcula imposto, fornecendo diferentes entradas e verificando as saÃ­das esperadas
    

#### 2.Â **Meio: Testes de IntegraÃ§Ã£o (Quantidade Moderada)**

Esses testes verificam a interaÃ§Ã£o e comunicaÃ§Ã£o entre mÃºltiplos "tijolos" ou unidades. Eles garantem que os mÃ³dulos, quando conectados, funcionam em conjunto conforme o design.

- **Objetivo:**Â Encontrar defeitos nas interfaces e interaÃ§Ãµes entre componentes integrados (ex.: uma API com seu banco de dados, ou dois microsserviÃ§os se comunicando)
    
- **CaracterÃ­sticas:**Â SÃ£oÂ **mais lentos**Â que os unitÃ¡rios, pois envolvem mais partes do sistema. SÃ£o mais complexos e caros de manter. A quantidade deve ser moderada, focando nas integraÃ§Ãµes crÃ­ticas
    
- **Exemplo:**Â Testar se um endpoint de API, quando chamado, persiste os dados corretamente no banco de dados
    

#### 3.Â **Topo: Testes End-to-End (E2E) (Poucos!)**

SÃ£o testes que simulam a jornada completa de um usuÃ¡rio real em um ambiente que espelha a produÃ§Ã£o. Eles passam por todas as camadas da aplicaÃ§Ã£o, from front-end to back-end.

- **Objetivo:**Â Validar fluxos de negÃ³cio crÃ­ticos e garantir que todo o sistema, como um conjunto, atende aos requisitos do usuÃ¡rio final
    
- **CaracterÃ­sticas:**Â SÃ£o os testesÂ **mais lentos, complexos, frÃ¡geis**Â (quebram com facilidade com pequenas mudanÃ§as na UI) eÂ **caros**Â de desenvolver e executar. Portanto, devem ser poucos e focados nos caminhos felizes (_happy paths_) mais importantes
    
- **Exemplo:**Â Simular um usuÃ¡rio realizando todo o processo de cadastro, login, adiÃ§Ã£o de um produto ao carrinho e finalizaÃ§Ã£o de compra em um e-commerce
    
![](./media/course/assets/piramede_tests_2.png)
### ğŸ’¡ ConclusÃ£o: A Regra de Ouro da PirÃ¢mide

A estratÃ©gia da pirÃ¢mide Ã© clara:Â **construa uma base larga e estÃ¡vel com muitos testes unitÃ¡rios rÃ¡pidos**. Esta base suporta uma camada intermediÃ¡ria de testes de integraÃ§Ã£o que validam as conexÃµes. Por fim, coroe o processo com um nÃºmero reduzido de testes E2E que validam os cenÃ¡rios mais crÃ­ticos do ponto de vista do usuÃ¡rio. Esta abordagem maximiza a confiabilidade e a velocidade de feedback, minimizando o custo total de testes.

---

### âš¡ Fail Fast: A Filosofia de Corrigir Cedo e Errar Barato

O princÃ­pioÂ **"Fail Fast"**Â (Falhar RÃ¡pido) Ã© um pilar cultural e tÃ©cnico do CI/CD. Ele prega que Ã© melhor descobrir um defeito o mais cedo possÃ­vel no ciclo de desenvolvimento, preferencialmente segundos apÃ³s ele ter sido introduzido.

- **A Economia do Erro:**Â O custo para corrigir um bug encontrado durante a codificaÃ§Ã£o (ou no commit) Ã© orders de magnitude menor do que aquele encontrado em produÃ§Ã£o. Envolve menos pessoas, menos contexto e menos rollback complexo
    
- **AplicaÃ§Ã£o no CI:**Â O pipeline de CI Ã© a materializaÃ§Ã£o deste princÃ­pio. Ele Ã© projetado para:
    
    - **Validar commits imediatamente**Â apÃ³s oÂ _push_        
    - **Rodar as verificaÃ§Ãµes mais rÃ¡pidas primeiro**Â (linting, testes unitÃ¡rios)        
    - **"Barrar" a passagem do cÃ³digo**Â ao primeiro sinal de problema, impedindo que um defeito prossiga para estÃ¡gios mais caros e complexos do pipeline
        
- **BenefÃ­cio:**Â Cria um ciclo de feedback ultrarrÃ¡pido para o desenvolvedor, que pode corrigir o problema enquanto o contexto ainda estÃ¡ fresco em sua mente
    

---

### ğŸ›¡ï¸ Testes NÃ£o-Funcionais: Os Atributos da Qualidade InvisÃ­vel

A qualidade de um software nÃ£o Ã© definida apenas pelo que ele faz (requisitos funcionais), mas tambÃ©mÂ **por como ele faz**. Estes sÃ£o os atributos de qualidade nÃ£o-funcionais, often conhecidos como os "-ilities":

- **Performance:**Â Como o sistema se comporta sob carga? Ele Ã© rÃ¡pido, responsivo e estÃ¡vel? Envolve testes de carga, estresse e volume
    
- **SeguranÃ§a:**Â O sistema estÃ¡ protegido contra ameaÃ§as e vulnerabilidades? Testes de seguranÃ§a procuram brechas para invasÃµes, vazamentos de dados e outros riscos
    
- **Usabilidade e Acessibilidade:**Â A interface Ã© intuitiva e fÃ¡cil de usar? Ela Ã© acessÃ­vel para pessoas com deficiÃªncia? (Embora often verificada manualmente, existem ferramentas automatizadas para aspectos de acessibilidade)
    
- **Confiabilidade (Reliability):**Â O sistema opera sem falhas por um perÃ­odo especÃ­fico?
    
- **Portabilidade:**Â O sistema pode ser facilmente implantado em diferentes ambientes?
    

Times de alta maturidadeÂ **automatizam a verificaÃ§Ã£o**Â desses atributos sempre que possÃ­vel, incorporando steps especÃ­ficos no pipeline (ex.: scan de seguranÃ§a de cÃ³digo, testes de carga em ambiente de staging) para garantir que a qualidade "invisÃ­vel" nÃ£o seja negligenciada.

---

## ğŸ” Steps de Qualidade no Pipeline CI/CD

### A LÃ³gica do Pipeline: Uma Corrida de Barreiras Inteligente

Um pipeline de CI/CD eficiente Ã© construÃ­do com uma lÃ³gica deÂ **otimizaÃ§Ã£o de custo e tempo**. Isso significa organizar os estÃ¡gios de verificaÃ§Ã£o em ordem crescente de complexidade e tempo de execuÃ§Ã£o. ComeÃ§a-se com as verificaÃ§ÃµesÂ **mais rÃ¡pidas e baratas**. Se o cÃ³digo falhar em uma etapa inicial, ele Ã© rejeitado imediatamente, poupando recursos computacionais e tempo que seriam gastos executando testes longos em um cÃ³digo que jÃ¡ se provou defeituoso.

A sequÃªncia tÃ­pica e lÃ³gica Ã©:

1. **ValidaÃ§Ã£o de Sintaxe e FormataÃ§Ã£o**Â (Mais RÃ¡pido/Barato)    
2. **AnÃ¡lise de SeguranÃ§a EstÃ¡tica e DependÃªncias**    
3. **Testes UnitÃ¡rios*    
4. **Testes de IntegraÃ§Ã£o**    
5. **Testes End-to-End e NÃ£o-Funcionais**Â (Mais Demorado/Caro)
    

---

### âœï¸ Commit Linting

- **O que Ã©:**Â A validaÃ§Ã£o automÃ¡tica da mensage de commit contra um padrÃ£o estabelecido (ex.: Conventional Commits)
    
- **Por que fazer:**Â Mensagens de commit padronizadas geram um histÃ³rico de cÃ³digo limpo e legÃ­vel, facilitam a automaÃ§Ã£o do versionamento semÃ¢ntico e melhoram a comunicaÃ§Ã£o da equipe sobre as mudanÃ§as
    
- **Ferramentas:**Â `Commitlint`,Â `Husky`    

---

### ğŸ¨ Linting de CÃ³digo

- **O que Ã©:**Â A anÃ¡lise estÃ¡tica do cÃ³digo-fonte paraå¼ºåˆ¶ar um estilo de codificaÃ§Ã£o consistente e identificar mÃ¡s prÃ¡ticas e erros Ã³bvios
    
- **Por que fazer:**Â MantÃ©m a codebase uniforme, reduz a "dÃ­vida tÃ©cnica" estÃ©tica e detecta bugs potenciais antes da execuÃ§Ã£o (ex.: variÃ¡veis nÃ£o declaradas)
    
- **Ferramentas:**Â `ESLint`Â (JavaScript),Â `Checkstyle`Â (Java),Â `Pylint`Â (Python),Â `RuboCop`Â (Ruby)
    

---

### ğŸ”’ SAST (Static Application Security Testing)

- **O que Ã©:**Â A anÃ¡lise do cÃ³digo-fonte (sem executÃ¡-lo) para identificar vulnerabilidades de seguranÃ§a, como injection flaws, cross-site scripting (XSS), e mÃ¡s prÃ¡ticas de codificaÃ§Ã£o que podem levar a brechas
    
- **Por que fazer:**Â Encontrar e corrigir vulnerabilidades na fase de desenvolvimento, onde o custo de remediaÃ§Ã£o Ã© mais baixo
    
- **Ferramentas:**Â `SonarQube`,Â `Semgrep`,Â `Checkmarx`
    

---

### ğŸ“¦ SCA (Software Composition Analysis)

- **O que Ã©:**Â A anÃ¡lise automatizada das dependÃªncias e bibliotecas de terceiros usadas no projeto
    
- **Por que fazer:**Â Identificar se as bibliotecas externas possuem vulnerabilidades de seguranÃ§a conhecidas (CVEs), sÃ£o de fontes confiÃ¡veis e estÃ£o em versÃµes suportadas
    
- **Ferramentas:**Â `Snyk`,Â `Dependabot`Â (GitHub),Â `WhiteSource`
    

---

### ğŸ³ AnÃ¡lise de Imagens de Container

- **O que Ã©:**Â O escaneamento de imagens Docker/OCI em busca de pacotes do sistema operacional e dependÃªncias de aplicaÃ§Ã£o que contenham vulnerabilidades
    
- **Por que fazer:**Â Garantir que la base da sua aplicaÃ§Ã£o em container (a imagem) nÃ£o introduza riscos de seguranÃ§a no ambiente de execuÃ§Ã£o
    
- **Ferramenta:**Â `Trivy`,Â `Grype`,Â `Docker Scout`
    

---

### ğŸ”‘ Scan de Secrets

- **O que Ã©:**Â A verificaÃ§Ã£o automÃ¡tica do cÃ³digo-fonte e do histÃ³rico de commits para detectar a exposiÃ§Ã£o acidental de credenciais, tokens de API, chaves privadas ou qualquer informaÃ§Ã£o sensÃ­vel
    
- **Por que fazer:**Â Prevenir vazamentos de dados e acessos nÃ£o autorizados que podem levar a violaÃ§Ãµes de seguranÃ§a graves
    
- **Ferramentas:**Â `Gitleaks`,Â `GitGuardian`,Â `TruffleHog`

---

### ğŸ¤– Testes Automatizados

- **O que Ã©:**Â A execuÃ§Ã£o automatizada da suÃ­te de testes, seguindo a estratÃ©gia da pirÃ¢mide
    
- **Ordem de ExecuÃ§Ã£o TÃ­pica:**
    
    1. **Testes UnitÃ¡rios:**Â Executados primeiro, sÃ£o a barreira inicial rÃ¡pida
        
    2. **Testes de IntegraÃ§Ã£o:**Â Executados em seguida, validam as interaÃ§Ãµes
        
    3. **Testes E2E:**Â Executados por Ãºltimo, often em um ambiente mais parecido com produÃ§Ã£o, validam o sistema como um todo
        
- **Por que fazer:**Â Fornecer confianÃ§a contÃ­nua de que novas alteraÃ§Ãµes nÃ£o quebraram funcionalidades existentes (regressÃ£o)

---

## ğŸŒ± A Mentalidade de Qualidade: AlÃ©m do CÃ³digo e das Ferramentas

AutomaÃ§Ã£o, pipelines e ferramentas sÃ£o fundamentais, mas aÂ **verdadeira transformaÃ§Ã£o em qualidade comeÃ§a com a mentalidade das pessoas**. Desenvolvedores, engenheiros de DevOps e QA precisam cultivar uma postura especÃ­fica para construir software excelente de forma sustentÃ¡vel.

### ğŸ¤”Â **MudanÃ§a de Pergunta:**

NÃ£o Ã© apenasÂ _"Meu cÃ³digo funciona?"_, mas sim:

- **"Como meu cÃ³digo se comporta em produÃ§Ã£o?"**    
- **"Ele Ã© fÃ¡cil de manter e entender por outros membros do time?"**    
- **"Que problemas eu estou prevenindo para o usuÃ¡rio final?"**    
- **"Estou deixando o cÃ³digo mais saudÃ¡vel do que encontrei?"**Â (PrincÃ­pioÂ _Boy Scout_)

### ğŸ‘¥Â **Empatia pelo UsuÃ¡rio e pelos Colegas:**

- **Pelo usuÃ¡rio:**Â Entender que cada bug, cada lentidÃ£o ou cada mensagem de erro confusa causaÂ **frustraÃ§Ã£o real**Â em uma pessoa. VocÃª nÃ£o estÃ¡ codificando para uma mÃ¡quina, estÃ¡ criando uma experiÃªncia para humanos
    
- **Pelos colegas:**Â Escrever cÃ³digo limpo e bem testado Ã© um ato de respeito com quem vai mantÃª-lo no futuro (que pode ser vocÃª mesmo daqui a 6 meses!). Um pipeline que falha rÃ¡pido Ã© um alerta Ãºtil, nÃ£o uma puniÃ§Ã£o

### ğŸŒÂ **Pensamento SistÃªmico: AlÃ©m do CÃ³digo-Fonte**

Um software nÃ£o vive isolado. Ele roda em uma infraestrutura, depende de serviÃ§os e Ã© usado por pessoas. Ter uma visÃ£o ampla do sistema Ã© crucial:

- **Entenda a Infraestrutura:**Â Compreender o bÃ¡sico deÂ _onde_Â eÂ _como_Â a aplicaÃ§Ã£o roda (containers, Kubernetes, servidores) permite tomar decisÃµes mais inteligentes. Um cÃ³digo que consome memÃ³ria de forma descontrolada, por exemplo, pode derrubar um container em produÃ§Ã£o.Â **Na dÃºvida, converse com o time de Infra/DevOps.**Â Essa colaboraÃ§Ã£o evita surpresas desagradÃ¡veis e resulta em uma aplicaÃ§Ã£o mais estÃ¡vel e performÃ¡tica
    
- **Colabore com o QA:**Â O tester Ã© seu aliado, nÃ£o seu adversÃ¡rio.Â **Converse com o time de QA**Â para entender cenÃ¡rios de teste complexos, edge cases e o ponto de vista do usuÃ¡rio que vocÃª pode nÃ£o ter considerado. Essa parceria antecipa bugs e fortalece a qualidade do produto
    
- **Foque na Dor Real:**Â Antes de mergulhar no cÃ³digo, pergunte-se:Â **"Qual Ã© a dor do usuÃ¡rio que estou resolvendo?"**Â eÂ **"Qual o problema que a operaÃ§Ã£o (suporte) enfrenta com isso?"**. Entender o contexto real do problema evita que vocÃª crie uma soluÃ§Ã£o tecnicamente elegante para a pergunta errada. Software existe para resolver problemas reais
    

### ğŸ”Â **Doneness â‰  Done (Pronto nÃ£o Ã© igual a Entregue):**

Uma feature nÃ£o estÃ¡ "pronta" apenas quando funciona no ambiente do desenvolvedor. Ela sÃ³ estÃ¡Â **"Done"**Â quando:

- âœ… EstÃ¡ com cÃ³digo revisado e seguindo os padrÃµes    
- âœ… Possui testes automatizados adequados    
- âœ… Passou por todas as verificaÃ§Ãµes de seguranÃ§a e qualidade do pipeline    
- âœ… EstÃ¡ documentada de forma clara    
- âœ… Foi implantada com sucesso em produÃ§Ã£o (e talvez atÃ© monitorada por um tempo)
    

### ğŸ§ Â **Cultura de Don't Hate, Automatize! (NÃ£o Odeie, Automatize!):**

- Encontrou um processo manual, chato e repetitivo?Â **Automatize.**    
- A equipe esquece de rodar um teste crÃ­tico?Â **Coloque no pipeline.**    
- Um passo de configuraÃ§Ã£o sempre dÃ¡ erro?Â **Torne-o infalÃ­vel com cÃ³digo (IaC).**    
- Esta mentalidade proativa Ã© o cerne do DevOps e da melhoria contÃ­nua    

### ğŸ¤Â **Qualidade Ã© Responsabilidade Coletiva:**

- **NÃ£o Ã© "o trabalho do QA" achar bugs.**Â Ã‰ trabalho doÂ _time_Â **nÃ£o entregar bugs**. O papel do QA Ã© crucial para elaborar estratÃ©gias, desafiar o sistema e garantir a qualidade do processo, nÃ£o ser o Ãºnico portÃ£o de saÃ­da
    
- **NÃ£o Ã© "o trabalho do DevOps" consertar o pipeline.**Â Ã‰ trabalho doÂ _time_Â **entender e escrever cÃ³digo que passe pelo pipeline**. Todos devem se sentir donos e contribuir para a eficiÃªncia da esteira de CI/CD
    

### ğŸ’¡Â **ConclusÃ£o Chave:**

As ferramentas tÃ©cnicas sÃ£o oÂ **"braÃ§o"**Â que implementa a qualidade. A mentalidade e as soft skills sÃ£o oÂ **"cÃ©rebro e o coraÃ§Ã£o"**Â que guiam esse braÃ§o. Cultive uma cultura onde a excelÃªncia tÃ©cnica ande de mÃ£os dadas com a colaboraÃ§Ã£o, a empatia, oÂ **pensamento sistÃªmico**Â e a melhoria contÃ­nua.Â **Software Ã©, antes de tudo, um produto da colaboraÃ§Ã£o humana.**

---

## âœ… Checklist de Aprendizado

Marque mentalmente se vocÃª compreende os seguintes conceitos:

- Compreendo que a qualidade integrada ao CI Ã© o que permite velocidade e confiabilidade verdadeiras    
- Sei explicar a estratÃ©gia por trÃ¡s da PirÃ¢mide de Testes e a razÃ£o da proporÃ§Ã£o entre os tipos de teste    
- Internalizei o princÃ­pio de "Fail Fast" e seus benefÃ­cios econÃ´micos e tÃ©cnicos
- ReconheÃ§o que testes nÃ£o-funcionais (performance, seguranÃ§a) sÃ£o tÃ£o crÃ­ticos quanto os funcionais    
- Consigo listar e explicar a finalidade dos principais steps de qualidade em um pipeline CI/CD:
    
    - Commit Linting        
    - Linting de CÃ³digo        
    - SAST        
    - SCA        
    - Scan de Secrets        
    - AnÃ¡lise de Imagens de Container        
    - ExecuÃ§Ã£o de Testes (Unit, Integration, E2E)
        
- Tenho clareza de que a qualidade Ã© uma responsabilidade compartilhada porÂ **todos os membros do time**Â que escrevem cÃ³digo, e nÃ£o apenas de testadores/QA
    
---
# ğŸ”— Recursos de Apoio

| Recurso | DescriÃ§Ã£o | Link |
|---------|-----------|------|
| **Artigo da PirÃ¢mide de Testes** | Artigo original por Martin Fowler (inglÃªs) | [martinfowler.com](https://martinfowler.com/articles/practical-test-pyramid.html) |
| **SAST - Red Hat** | ExplicaÃ§Ã£o sobre Static Application Security Testing | [redhat.com](https://www.redhat.com/pt-br/topics/security/what-is-sast) |
| **SonarQube** | DocumentaÃ§Ã£o oficial da ferramenta de qualidade de cÃ³digo | [sonarqube.org](https://www.sonarqube.org/) |
| **ESLint** | DocumentaÃ§Ã£o do linter para JavaScript/TypeScript | [eslint.org](https://eslint.org/) |
| **Trivy** | DocumentaÃ§Ã£o do scanner de seguranÃ§a | [aquasecurity.github.io](https://aquasecurity.github.io/trivy/) |
| **Gitleaks** | RepositÃ³rio oficial do detector de segredos | [github.com/gitleaks](https://github.com/gitleaks/gitleaks) |
| **GitGuardian** | Site oficial da plataforma de seguranÃ§a | [gitguardian.com](https://www.gitguardian.com/) |
---

> **ğŸ  Voltar ao Ãndice:**Â [Ãndice do Curso](../course)  
> **â¬…ï¸ Anterior:**Â [Day-02 - Fundamentos do Git e Versionamento](./Day-02/02.md)  
> **â¡ï¸ PrÃ³ximo:**Â [Day-04 - IntroduÃ§Ã£o a Ferramentas de CI](../Day-04/04.md)