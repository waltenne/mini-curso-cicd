---
banner_image: media/banner.png
tags: [ci, cd, devops, fundamentos, cicd]
toc: true
extra:
  math: true
  mermaid: true
  mermaid_theme: default
---

# Day-02 | Controlando a BagunÃ§a - Versionamento e ColaboraÃ§Ã£o

---

## ğŸ“Œ Objetivos de Aprendizado 
s
- Compreender as diferenÃ§as fundamentais entre Git Flow e Trunk-Based Development
- Entendimento do Semantic Versioning em seus projetos
- Entendimento do Conventional Commits para padronizaÃ§Ã£o de mensagens
- Entender a importÃ¢ncia dos commits atÃ´micos no fluxo de CI/CD
- Relacionar prÃ¡ticas de versionamento com a eficiÃªncia dos pipelines

---

## ğŸ§© Por que versionamento importa para CI/CD?

O controle de versÃ£o Ã© a **espinha dorsal** que sustenta todo processo de CI/CD. Sem ele:  
- NÃ£o hÃ¡ como rastrear mudanÃ§as  
- ColaboraÃ§Ã£o torna-se caÃ³tica  
- ImplantaÃ§Ãµes ficam imprevisÃ­veis  

---

## ğŸ”€ Git Workflows: Filosofias em confronto

Quando falamos em desenvolvimento colaborativo com Git, existem diferentes estratÃ©gias para organizar o fluxo de trabalho.  
Duas das mais conhecidas sÃ£o **Git Flow** e **Trunk-Based Development**.  
Ambas tÃªm o mesmo objetivo â€” garantir colaboraÃ§Ã£o eficiente e qualidade no cÃ³digo â€” mas seguem filosofias bem diferentes.

---

### ğŸ§© O que Ã© Git Flow?
O **Git Flow** Ã© um modelo de ramificaÃ§Ã£o proposto por Vincent Driessen em 2010.  
Ele introduz uma **estrutura hierÃ¡rquica de branches**, onde cada tipo de branch tem um papel definido:

- `main` (ou `master`) â†’ mantÃ©m a versÃ£o estÃ¡vel em produÃ§Ã£o.  
- `develop` â†’ concentra o desenvolvimento ativo.  
- `feature/*` â†’ criadas para novas funcionalidades.  
- `release/*` â†’ preparaÃ§Ã£o de versÃµes para produÃ§Ã£o.  
- `hotfix/*` â†’ correÃ§Ãµes rÃ¡pidas em produÃ§Ã£o.  

ğŸ“Œ **CaracterÃ­sticas principais**:
- Adequado para projetos com **ciclos de release mais longos**.  
- Favorece produtos que precisam **manter mÃºltiplas versÃµes em paralelo**.  
- Garante maior **controle de versionamento**, mas com custo de **complexidade**.  

---

### ğŸ“Š Fluxo Git Flow (Mermaid)

```mermaid
gitGraph
    commit id: "InÃ­cio"
    branch develop
    commit id: "Base dev"

    branch feature/xyz
    commit id: "Feature work"
    checkout develop
    merge feature/xyz id: "Merge feature"

    branch release/1.0
    commit id: "Preparar release"
    checkout main
    merge release/1.0 id: "Release 1.0"
    commit id: "Tag v1.0"

    branch hotfix/1.0.1
    commit id: "CorreÃ§Ã£o crÃ­tica"
    checkout main
    merge hotfix/1.0.1 id: "Hotfix aplicado"
    commit id: "Tag v1.0.1"

    checkout develop
    merge hotfix/1.0.1 id: "Sync hotfix"
```
---
### ğŸŒ± O que Ã© Trunk-Based Development?
O **Trunk-Based Development (TBD)** Ã© uma abordagem mais enxuta e Ã¡gil.  
Em vez de vÃ¡rias branches, os desenvolvedores trabalham quase sempre em uma Ãºnica branch principal, chamada de **trunk** (ou `main`).  

- Todos os desenvolvedores integram mudanÃ§as diretamente (ou via pull requests curtos).  
- Branches de feature existem, mas sÃ£o **curtas e de curta duraÃ§Ã£o** (horas ou poucos dias).  
- A filosofia Ã© baseada em **integraÃ§Ã£o contÃ­nua e entregas frequentes**.  

ğŸ“Œ **CaracterÃ­sticas principais**:
- Adequado para equipes com **CI/CD bem estabelecido**.  
- Requer **alta disciplina** em testes automatizados e code reviews rÃ¡pidos.  
- Favorece **deploys frequentes e menores**, reduzindo riscos.  

---

### ğŸ“Š Fluxo Trunk-Based Development (Mermaid)


```mermaid
gitGraph
    commit id: "Trunk inÃ­cio"
    commit id: "Commit dev A"
    commit id: "Commit dev B"

    branch feature/curta
    commit id: "Feature rÃ¡pida"
    checkout main
    merge feature/curta id: "Merge feature"

    commit id: "Deploy contÃ­nuo"
    commit id: "Nova melhoria"
```
---

### âš–ï¸ ComparaÃ§Ã£o lado a lado

| CaracterÃ­stica    | Git Flow                       | Trunk-Based Development        |
| ----------------- | ------------------------------ | ------------------------------ |
| **Estrutura**     | Branches longas (dev, release) | Branch principal Ãºnica (trunk) |
| **IntegraÃ§Ã£o**    | Merges periÃ³dicos              | Commits frequentes e pequenos  |
| **Indicado para** | Projetos com versÃµes paralelas | Equipes maduras e CI/CD sÃ³lido |
| **Vantagem**      | Controle rigoroso de versÃµes   | IntegraÃ§Ã£o contÃ­nua natural    |
| **Desvantagem**   | Complexidade de gerenciamento  | Requer disciplina e automaÃ§Ã£o  |

---

### ğŸ“Œ Quando usar cada um?
- **Git Flow** â†’ indicado para **sistemas legados** ou **produtos com mÃºltiplas versÃµes** em produÃ§Ã£o.  
- **Trunk-Based Development** â†’ ideal para **startups, microsserviÃ§os** e **times Ã¡geis com deploy contÃ­nuo**.  

---
## ğŸ”¢ Semantic Versioning (SemVer): A matemÃ¡tica das versÃµes

O **Semantic Versioning** (SemVer) Ã© um padrÃ£o de versionamento criado para trazer **clareza e previsibilidade** na evoluÃ§Ã£o de software.  
Ele segue a lÃ³gica **MAJOR.MINOR.PATCH**, por exemplo: `2.5.3`.  

### O que Ã© e por que usar

- **MAJOR (X.0.0):** MudanÃ§as incompatÃ­veis que podem quebrar aplicaÃ§Ãµes que dependem da versÃ£o anterior.  
- **MINOR (0.X.0):** Funcionalidades novas que nÃ£o afetam compatibilidade.  
- **PATCH (0.0.X):** CorreÃ§Ãµes de bugs e pequenas melhorias que nÃ£o alteram funcionalidades.  

**Por que isso importa?**  
- ComunicaÃ§Ã£o clara entre desenvolvedores e usuÃ¡rios.  
- Previsibilidade no impacto de uma atualizaÃ§Ã£o.  
- Compatibilidade garantida em ambientes de produÃ§Ã£o.  

### Regras e boas prÃ¡ticas

1. **Imutabilidade:** uma versÃ£o publicada nunca deve mudar.  
2. **TransparÃªncia:** cada incremento deve refletir exatamente o impacto da mudanÃ§a.  
3. **AutomaÃ§Ã£o:** pipelines podem interpretar nÃºmeros de versÃ£o e decidir sobre deploys.  
4. **Metadados:** podem ser adicionados ao final (ex: `1.2.3+20230911`) para build tracking.  

### Riscos de nÃ£o aplicar corretamente

- DependÃªncias quebradas em produÃ§Ã£o.  
- Dificuldade em identificar de onde surgiu um bug.  
- Equipes perdem confianÃ§a no processo de release.  
- Pipelines deixam de ser previsÃ­veis.  

---

### ğŸ“Š Fluxo de DecisÃ£o SemVer (Mermaid)

```mermaid
flowchart TD
    A[Commit realizado] --> B{Tipo de mudanÃ§a?}
    B -->|Quebra de compatibilidade| C[MAJOR +1<br/>Ex: 2.0.0]
    B -->|Nova funcionalidade compatÃ­vel| D[MINOR +1<br/>Ex: 1.3.0]
    B -->|Bug fix / melhorias pequenas| E[PATCH +1<br/>Ex: 1.2.4]
```

## âœ¨ Cultura do Commit SaudÃ¡vel

### ğŸ’¡ Conventional Commits: Padronizando Mensagens

OÂ **Conventional Commits**Â Ã© uma convenÃ§Ã£o simples e amplamente adotada para escrever mensagens de commit de forma padronizada, clara e automatizÃ¡vel. Ele estabelece um formato consistente que facilita a leitura do histÃ³rico e a automaÃ§Ã£o de processos.

#### **ğŸ“– Mensagem de Commit - Guia Detalhado**

Uma boa mensagem de commit funciona como um GPS para o histÃ³rico do projeto. Ela precisa ser **clara, objetiva e autoexplicativa**, permitindo que qualquer colaborador entenda a mudanÃ§a sem precisar decifrar o cÃ³digo. 


ğŸ’¡ **Dica:** Na hora de Criar mensagem de commit, imagine que voce estÃ¡ continuando essa frase `Se eu aplicar esse commit, ele vai...`

Segue um guia prÃ¡tico:

**Estrutura Ideal**  
Use o formato: `tipo(escopo-opcional): descriÃ§Ã£o concisa`  
- **Tipo**: Indica a natureza da mudanÃ§a (ex: feat, fix, docs)  
- **Escopo**: Especifica o mÃ³dulo/Ã¡rea afetada (opcional)  
- **DescriÃ§Ã£o**: Explica a mudanÃ§a em tempo presente ("Adiciona" em vez de "Adicionei")

**Exemplos Ampliados**  
1. `feat(layout): adicionar suporte para exportaÃ§Ã£o em TXT`  
   *(Novo recurso no mÃ³dulo de layout, Ãºtil para integraÃ§Ã£o com sistemas legados)*  

2. `fix(autenticaÃ§Ã£o): corrigir timeout na comunicaÃ§Ã£o com WebSocket`  
   *(Resolve erro crÃ­tico que causava desconexÃµes apÃ³s 2min de inatividade)*  

3. `test(pagamento): adicionar suite de testes para API de cartÃµes`  
   *(Cobre cenÃ¡rios de edge cases como CVV invÃ¡lido e cartÃµes expirados)*  

4. `ci: atualizar versÃ£o do Node.js para 18.x no pipeline`  
   *(Melhoria de infraestrutura que resolve vulnerabilidades de seguranÃ§a)*  

**Boas PrÃ¡ticas**  
âœ”ï¸ Use verbos no imperativo ("Corrigir" em vez de "Corrigindo")  
âœ”ï¸ Limite a 50 caracteres no tÃ­tulo  
âœ”ï¸ Detalhe o "porquÃª" no corpo da mensagem quando necessÃ¡rio  
âœ”ï¸ Referencie issues/tickets (ex: `JIRA-123`)  

**Tipos Comuns**  
- `feat`: Novas funcionalidades  
- `fix`: CorreÃ§Ãµes de bugs  
- `docs`: AtualizaÃ§Ãµes documentais  
- `refactor`: Melhorias de cÃ³digo sem mudar funcionalidades  
- `chore`: Tarefas de manutenÃ§Ã£o (dependÃªncias, configuraÃ§Ãµes) 
- `ci`: Ajustes relacionado ao CI do projeto

ğŸ’¡ **Dica extra:** Mantenha consistÃªncia nos emojis caso utilize (ex: ğŸ› para bugs, âœ¨ para novas features), mas evite exageros. Uma mensagem bem escrita economiza horas de debugging e facilita o code review!


### ğŸš€ BenefÃ­cios para Equipes e Pipelines

- **ğŸ“– HistÃ³rico LegÃ­vel:**Â Facilita a auditoria e o entendimento da evoluÃ§Ã£o do cÃ³digo. 
- **ğŸ¤– GeraÃ§Ã£o Automatizada de Changelog:**Â Ferramentas comoÂ `standard-version`Â ouÂ `semantic-release`Â podem gerar notas de versÃ£o automaticamente. 
- **ğŸ” IntegraÃ§Ã£o com CI/CD:**Â Commits especÃ­ficos podem acionar etapas seletivas em pipelines de integraÃ§Ã£o e deploy. 
- **ğŸ“Œ Rastreabilidade:**Â Permite vincular commits a issues, tarefas ou itens do backlog.   
- **ğŸ§  Onboarding Acelerado:**Â Novos membros do time compreendem o histÃ³rico do projeto mais rapidamente.
    

---

## âš¡ Atomicidade: A Arte do Commit Perfeito

### ğŸ” PrincÃ­pios dos Commits AtÃ´micos

1. **Uma AlteraÃ§Ã£o por Commit:**Â Cada commit deve representar uma Ãºnica mudanÃ§a lÃ³gica.    
2. **Nunca Quebrar o Build:**Â O cÃ³digo deve estar sempre em um estado funcional apÃ³s cada commit.    
3. **Mensagem Clara e Autoexplicativa:**Â A descriÃ§Ã£o deve deixar claro o propÃ³sito da mudanÃ§a.

### âš™ï¸ Vantagens para o Desenvolvimento

Commits atÃ´micos sÃ£o fundamentais para operaÃ§Ãµes eficientes no Git, permitindo:

- **ğŸ”„ Revertibilidade:**Â Reverter features ou correÃ§Ãµes especÃ­ficas de forma segura e precisa.
- **ğŸ” Busca Precisas comÂ `git bisect`:**Â Isolar a introduÃ§Ã£o de bugs de maneira rÃ¡pida e eficiente.
- **ğŸš€ Deployments Seletivos:**Â Implantar hotfixes crÃ­ticos sem levar outras alteraÃ§Ãµes nÃ£o relacionadas.

---

## âœ… Checklist de Aprendizado

-  Sei explicar diferenÃ§as entre Git Flow e Trunk-Based    
-  Consigo aplicar SemVer corretamente em um projeto    
-  Entendo a importÃ¢ncia dos Conventional Commits    
-  ReconheÃ§o commits atÃ´micos em um histÃ³rico    
-  Compreendo a relaÃ§Ã£o entre versionamento e CI/CD
    
---

## ğŸ”— Recursos de Apoio

| Tipo             | Link                                                          | DescriÃ§Ã£o             |
| ---------------- | ------------------------------------------------------------- | --------------------- |
| ğŸ“– DocumentaÃ§Ã£o | [Semantic Versioning](https://semver.org/)                    | EspecificaÃ§Ã£o oficial |
| ğŸŒ DocumentaÃ§Ã£o | [Trunk-Based Development](https://trunkbaseddevelopment.com/) | Guia prÃ¡tico          |
| ğŸ“„ DocumentaÃ§Ã£o | [Conventional Commits](https://www.conventionalcommits.org/)  | PadrÃµes de mensagens  |
| ğŸ¥ VÃ­deo        | [Git Flow // DicionÃ¡rio do Programador](https://www.youtube.com/watch?v=oweffeS8TRc)  | CÃ³digo Fonte TV |
| ğŸ¥ VÃ­deo        | [Como padronizar commits?](https://www.youtube.com/watch?v=1eTofdmfq1g)  | Mario Souto - Dev Soutinho   |
| ğŸ¥ VÃ­deo        | [O Que Ã© Versionamento SemÃ¢ntico (SEMVER)](https://www.youtube.com/watch?v=hOYL5TJwACc) | The Cloud Bootcamp |

---

> **â¬…ï¸ Anterior:** [Day-01 | Os Alicerces â€” Por que CI/CD importa?](01.html)    
> **â¡ï¸ PrÃ³ximo:** [Day-03 | Garantia de Qualidade â€” O CoraÃ§Ã£o do CI](03.html)  
> **ğŸ  Voltar ao Ãndice:** [Ãndice do Curso](home.html)