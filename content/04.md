---
banner_image: media/banner.png
tags: [ci, cd, devops, fundamentos, cicd, artefatos, deployment]
toc: true
extra:
  math: true
  mermaid: true
  mermaid_theme: default

---

# Day-04 | Do CI ao CD - Artefatos, Entrega e Deploy ContÃ­nuo

## ğŸ“Œ Objetivos de Aprendizado 

- ğŸ”— Conectar **qualidade do CI** com **entrega do CD**
- ğŸ“¦ Implementar **artefatos imutÃ¡veis** como resultado do pipeline
- ğŸš€ Distinguir **Continuous Delivery** vs **Continuous Deployment**
- ğŸ¯ Escolher estratÃ©gias de deploy baseadas em **risco e confianÃ§a**
- ğŸ›¡ï¸ Projetar **gates de qualidade** que evoluem do CI para o CD
- ğŸ“Š Analisar casos reais aplicando conceitos dos dias anteriores

---

## ğŸ”— Ponte CI â†’ CD: A Qualidade como FundaÃ§Ã£o

### ğŸ¯ Relembrando Nossa Jornada

**Onde estamos e como chegamos aqui:**

```mermaid
flowchart TD
    A[Day-01<br/>Por que CI/CD importa] --> B[Day-02<br/>Versionamento & ColaboraÃ§Ã£o]
    B --> C[Day-03<br/>Garantia de Qualidade]
    C --> D[ğŸ¯ Day-04<br/>Do CI ao CD]
    D --> E[Day-05<br/>Juntando Tudo]
    
    style D fill:#e1f5fe,stroke:#01579b,stroke-width:3px
```

### ğŸ”„ Do "CÃ³digo Funciona" para "CÃ³digo Entrega"

**No Day-03** vimos sobre **qualidade de cÃ³digo**.  
**No Day-04** vamos aprender como garantir que **o cÃ³digo entrega valor**.

```mermaid
flowchart LR
    A[Commit] --> B[CI Pipeline]
    B --> C[Testes UnitÃ¡rios]
    B --> D[Testes IntegraÃ§Ã£o] 
    B --> E[Qualidade CÃ³digo]
    C & D & E --> F[âœ… CI Passou]
    F --> G[ğŸ¯ Gerar Artefato]
    G --> H[CD Pipeline]
    H --> I[Deploy Staging]
    H --> J[Testes AceitaÃ§Ã£o]
    H --> K[ValidaÃ§Ã£o ProduÃ§Ã£o]
```

---

## ğŸ§© Artefatos: O "Produto Final" do CI

### ğŸ“¦ O que SÃ£o Artefatos e Por que Importam?

Pensa nos artefatos como o resultado final do seu trabalho â€” aquilo que sai do outro lado do pipeline de CI.
Ã‰ o seu cÃ³digo transformado em algo que pode ser realmente usado, testado e entregue.

**Analogia:** Se o cÃ³digo-fonte Ã© a receita, o artefato Ã© o **bolo embalado e testado** pronto pra ser servido!.

### ğŸ—ï¸ Conectando com Conceitos Anteriores

**Lembra do Day-02?**

Agora o versionamento semÃ¢ntico comeÃ§a a mostrar seu valor.

Com ele, conseguimos identificar exatamente qual versÃ£o e qual commit gerou aquele artefato:

```bash
# Versionamento que conecta CI com CD
ARTIFACT_VERSION="1.4.3+$(git rev-parse --short HEAD)"
# Resultado: 1.4.3+a1b2c3d4
# Agora sabemos EXATAMENTE qual commit estÃ¡ onde!
```

**E do Day-03?**

Toda a parte de qualidade entra aqui â€” testes, padrÃµes, seguranÃ§a... tudo isso garante que o artefato final seja confiÃ¡vel.

```yaml
# Pipeline evolutivo - conectando todos os conceitos
stages:
  - lint           # ğŸ‘ˆ Day-02: PadrÃ£o de Commit
  - test           # ğŸ‘ˆ Day-03: PirÃ¢mide de Testes  
  - security_scan  # ğŸ‘ˆ Day-03: SAST/SCA
  - build          # ğŸ¯ Day-04: Gera o Artefato
  - deploy_staging # ğŸ¯ Day-04: CD - Entrega
  - deploy_prod    # ğŸ¯ Day-04: CD - ImplantaÃ§Ã£o
```

### ğŸ”’ O PrincÃ­pio da Imutabilidade na PrÃ¡tica

**Problema comum:**
```bash
# âŒ "Funciona na minha mÃ¡quina" vira "Quebrou em produÃ§Ã£o"
# Build Segunda: app-v1.0.0.jar
# Build TerÃ§a:   app-v1.0.0.jar (MAS DIFERENTE!)
```

O que acontece aqui Ã© que o artefato muda de um dia pro outro â€” e isso Ã© receita pra dor de cabeÃ§a.

A soluÃ§Ã£o? **Artefatos imutÃ¡veis:**

```bash
# âœ… Mesmo artefato, todos os ambientes
app-v1.0.0+a1b2c3d4.jar â†’ HomologaÃ§Ã£o âœ…
app-v1.0.0+a1b2c3d4.jar â†’ ProduÃ§Ã£o âœ…
# Exatamente o mesmo arquivo!
```

Quando o artefato nÃ£o muda, vocÃª sabe que o que testou Ã© exatamente o que estÃ¡ rodando.

### ğŸ› ï¸ Hands-On: Criando seu Primeiro Artefato ImutÃ¡vel

Exemplo simples usando Docker com metadados:

```dockerfile
FROM openjdk:11-jre-slim

# Metadados de rastreabilidade (Day-02 + Day-04)
LABEL version="1.4.3+a1b2c3d4" \
      build_timestamp="2024-01-15T10:30:00Z" \
      commit_hash="a1b2c3d4" \
      tests_passed="true" \
      security_scan="clean"

COPY app.jar /app/app.jar

# Checksum para verificaÃ§Ã£o de integridade
RUN sha256sum /app/app.jar > /app/app.jar.sha256

CMD ["java", "-jar", "/app/app.jar"]
```

Antes de enviar pra produÃ§Ã£o, dÃ¡ pra conferir se o arquivo estÃ¡ 100% Ã­ntegro:

```bash
# No pipeline de CD - validando integridade
sha256sum -c app.jar.sha256
# âœ… app.jar: OK - Pronto para deploy!
```

---

## âš™ï¸ Da IntegraÃ§Ã£o Ã  Entrega: A EvoluÃ§Ã£o do Pipeline

### ğŸ” Continuous Delivery (CD): "Sempre Pronto para Entregar"

Pensa no Continuous Delivery (CD) como o prÃ³ximo passo natural depois do CI.

ğŸ‘‰ Enquanto o CI garante que â€œo cÃ³digo funcionaâ€,
o CD garante que â€œo cÃ³digo estÃ¡ pronto para ser entregue a qualquer momentoâ€.

Ã‰ aqui que todo o trabalho dos dias anteriores se conecta:
- âœ… **Day-02**: Versionamento semÃ¢ntico â†’ sabemos exatamente o que estamos entregando.
- âœ… **Day-03**: Testes automatizados â†’ confiamos que o que entregamos funciona.  
- ğŸ¯ **Day-04**: Artefatos imutÃ¡veis â†’ entregamos exatamente o que foi testado.

Em outras palavras: o CD Ã© aquele momento em que o time pode dizer com seguranÃ§a â€” â€œse quiser, podemos colocar isso em produÃ§Ã£o agora.â€


**Fluxo do Continuous Delivery:**
```mermaid
flowchart LR
    A[CÃ³digo] --> B[Build CI]
    B --> C[Testes CI]
    C --> D[Artefato ImutÃ¡vel]
    D --> E[Deploy Staging]
    E --> F[Testes AceitaÃ§Ã£o]
    F --> G{ğŸ¤” Aprovar ProduÃ§Ã£o?}
    G -->|SIM| H[Deploy ProduÃ§Ã£o]
    G -->|NÃƒO| I[Corrigir]
    
    style G fill:#fff3e0,stroke:#ff6f00
```

Esse fluxo mostra bem o espÃ­rito do CD: tudo automatizado atÃ© o ponto da decisÃ£o final.
Quem dÃ¡ o â€œOKâ€ para produÃ§Ã£o ainda Ã© um humano â€” o sistema sÃ³ espera a confirmaÃ§Ã£o.

### âš¡ Continuous Deployment: "Entregando Automaticamente"

Agora, o Continuous Deployment (tambÃ©m CD) Ã© como levar o Continuous Delivery um passo alÃ©m.

Aqui, nem precisa de aprovaÃ§Ã£o manual:
passou nos testes â†’ vai pra produÃ§Ã£o automaticamente.
Simples assim.

A diferenÃ§a entre eles fica clara assim:

```mermaid
flowchart TD
    A[Artefato Validado] --> B{Qual estratÃ©gia?}
    
    B --> C[Continuous Delivery]
    C --> D[ğŸŸ¡ Deploy Manual<br/>Posso implantar quando quiser]
    D --> E[DecisÃ£o Humana]
    
    B --> F[Continuous Deployment]
    F --> G[ğŸŸ¢ Deploy AutomÃ¡tico<br/>Implanto automaticamente]
    G --> H[ConfianÃ§a Total]
    
    style C fill:#fff3e0,stroke:#ff6f00
    style F fill:#e8f5e8,stroke:#4caf50
```

O Continuous Delivery Ã© como ter o carro ligado, pronto pra sair.

O Continuous Deployment Ã© colocar o carro no piloto automÃ¡tico â€” ele vai sozinho, porque vocÃª confia 100% no sistema.

### ğŸ¯ Quando Escolher Cada Abordagem?

Tudo se resume a nÃ­vel de confianÃ§a no seu pipeline e nos testes.

Pense assim:
```mermaid
flowchart TD
    A[Novo Artefato] --> B{Qual confianÃ§a do CI?}
    
    B -->|Alta ConfianÃ§a<br/>âœ… Testes >90%<br/>âœ… SAST Limpo<br/>âœ… Pipeline EstÃ¡vel| C[Continuous Deployment]
    C --> D[Deploy AutomÃ¡tico]
    
    B -->|ConfianÃ§a Moderada<br/>âš ï¸ Testes >80%<br/>âš ï¸ Alguns testes manuais| E[Continuous Delivery]
    E --> F[Deploy com AprovaÃ§Ã£o]
    
    B -->|Baixa ConfianÃ§a<br/>âŒ Testes <80%<br/>âŒ Pipeline InstÃ¡vel| G[Deploy Manual]
    G --> H[Testes Extensivos + Gates]
    
    style C fill:#e8f5e8,stroke:#4caf50
    style E fill:#fff3e0,stroke:#ff6f00
    style G fill:#ffebee,stroke:#f44336
```

Resumindo:

. Se seu pipeline Ã© maduro e confiÃ¡vel, vÃ¡ de Continuous Deployment.

. Se ainda precisa de uma validaÃ§Ã£o humana, Continuous Delivery Ã© o caminho.

. E se o pipeline ainda Ã© instÃ¡vel, nada de pressa â€” deploy manual Ã© mais seguro.


---

## ğŸš€ EstratÃ©gias de Deploy: Engenharia de Confiabilidade

### ğŸŒˆ Blue-Green Deployment: Troca Segura

Depois que o cÃ³digo estÃ¡ pronto pra ser entregue, vem a grande pergunta:

ğŸ‘‰ Como colocar isso em produÃ§Ã£o sem quebrar nada?

Ã‰ aÃ­ que entram as **estratÃ©gias de deploy** â€” formas inteligentes de publicar novas versÃµes com **seguranÃ§a, controle e confianÃ§a**.

```mermaid
flowchart LR
    subgraph Blue[Blue - VersÃ£o Atual]
        A[App v1.2.0] --> LB[Load Balancer]
    end
    
    subgraph Green[Green - Nova VersÃ£o]
        B[App v1.3.0] --> LB
    end
    
    LB --> Users[UsuÃ¡rios]
    
    Blue -.->|ğŸ“± 100% UsuÃ¡rios| Users
    Green -.->|ğŸ”„ Troca InstantÃ¢nea| Users
```
Quando tudo estiver testado e funcionando no ambiente Green, basta mudar o trÃ¡fego do load balancer â€” e pronto! Todos os usuÃ¡rios passam a usar a nova versÃ£o sem nenhum downtime.

Se algo der errado, Ã© sÃ³ redirecionar o trÃ¡fego de volta pra Blue. Rollback instantÃ¢neo. ğŸš€

**Por que Ã© tÃ£o bom?**

âœ… **Zero downtime:** ninguÃ©m percebe a troca.

âœ… **Rollback rÃ¡pido:** se algo falhar, volta em segundos.

âœ… **Teste em produÃ§Ã£o:** dÃ¡ pra validar a versÃ£o nova antes de liberar geral.

### ğŸ¦ Canary Releases: LiberaÃ§Ã£o Inteligente

**Quando usar:** quando vocÃª quer liberar algo novo aos poucos, reduzindo o risco.

Aqui, a ideia Ã© lanÃ§ar a nova versÃ£o (o â€œcanÃ¡rioâ€) **apenas pra uma pequena parcela dos usuÃ¡rios** tipo 5% e monitorar o comportamento antes de liberar pra todo mundo.

```mermaid
graph TD
    A[100% UsuÃ¡rios] -->|5%| B[Canary v1.3.0]
    A -->|95%| C[ProduÃ§Ã£o v1.2.0]
    B --> D[ğŸ“Š Monitoramento ContÃ­nuo]
    
    D -->|âœ… MÃ©tricas OK| E[Escalonar para 25%]
    E --> F[Escalonar para 50%]
    F --> G[Escalonar para 100%]
    
    D -->|âŒ Problemas Detectados| H[ğŸš¨ Rollback Imediato]
    
    style B fill:#fff3e0,stroke:#ff6f00
```

Durante esse processo, vocÃª acompanha as mÃ©tricas em tempo real.
Se tudo estiver dentro do esperado, aumenta gradualmente a porcentagem de usuÃ¡rios.
Mas se algo sair do controle â€” rollback na hora.

O que monitorar (ligando com o Day-03):

```yaml
canary_metrics:
  error_rate:     "< 0.1%"    # ğŸ‘ˆ Lembra dos testes automatizados?
  latency_p95:    "< 500ms"   # ğŸ‘ˆ Performance que validamos no CI
  throughput:     "> 1000rpm" # ğŸ‘ˆ Capacidade do sistema
  business_metrics:           # ğŸ‘ˆ MÃ©tricas de negÃ³cio
    - conversion_rate
    - user_satisfaction
```

Essas mÃ©tricas garantem que o sistema continua saudÃ¡vel, e que o que estÃ¡ indo pro ar realmente entrega valor.

ğŸ¯ Como Escolher a EstratÃ©gia Certa?

NÃ£o existe bala de prata tudo depende do nÃ­vel de risco e do tipo de mudanÃ§a que vocÃª vai fazer.
Aqui vai um guia prÃ¡tico:


|CenÃ¡rio|EstratÃ©gia Recomendada|Por quÃª?|
|---|---|---|
|ğŸ’³ AplicaÃ§Ã£o crÃ­tica (banco, saÃºde, etc.)|	Blue-Green|	Rollback instantÃ¢neo pode evitar prejuÃ­zos sÃ©rios|
|ğŸ§ª Feature nova e arriscada|	Canary Release|	Permite testar aos poucos e limitar o impacto|
|ğŸ Bug fix simples|	Rolling Update|	AtualizaÃ§Ã£o rÃ¡pida e eficiente|
|ğŸ§± MudanÃ§a de infraestrutura|	Blue-Green|	Isolamento total dos ambientes traz seguranÃ§a extra|

ğŸ‘‰ Resumindo:

* *Blue-Green Ã© pra quem precisa de zero downtime e rollback instantÃ¢neo.

* *Canary Ã© pra quem quer reduzir risco e observar o impacto real antes de liberar pra todos.

* E o segredo de tudo isso? Monitoramento e confianÃ§a no pipeline.

---

## ğŸ›‚ Gates de Qualidade: Evoluindo do CI para o CD

### ğŸ”„ Do Desenvolvimento para ProduÃ§Ã£o

Chegamos ao ponto em que qualidade nÃ£o Ã© mais sÃ³ um â€œcheckâ€ no CI â€” ela agora controla o fluxo da entrega.
Esses sÃ£o os famosos â€œgates de qualidadeâ€: barreiras inteligentes que sÃ³ deixam o cÃ³digo seguir se ele realmente estiver pronto.

Pensa assim: cada gate Ã© como uma catraca que sÃ³ gira quando todos os critÃ©rios de qualidade foram cumpridos.
Se algo falha, o pipeline simplesmente nÃ£o avanÃ§a â€” e isso Ã© Ã³timo, porque evita levar problema pra produÃ§Ã£o. ğŸš§

```mermaid
flowchart TD
    A[Commit] --> B[CI Gates<br/>Day-03]
    B --> C[âœ… Unit Tests >80%]
    B --> D[âœ… SAST Limpo]
    B --> E[âœ… SCA Aprovado]
    
    C & D & E --> F[Artefato ImutÃ¡vel]
    F --> G[CD Gates<br/>Day-04]
    G --> H[ğŸ”„ Integration Tests]
    G --> I[ğŸ“Š Performance Tests]
    G --> J[ğŸ”’ Security Validation]
    G --> K[ğŸ‘¥ User Acceptance]
    
    H & I & J & K --> L[ğŸ¯ ProduÃ§Ã£o]
```

ğŸ‘‰ Ou seja: o que comeÃ§a com testes unitÃ¡rios, lint e seguranÃ§a no CI, evolui para testes de integraÃ§Ã£o, performance, seguranÃ§a e aceitaÃ§Ã£o no CD.
Tudo isso garante que cada etapa sÃ³ avanÃ§a se estiver realmente validada.

### ğŸ“Š CritÃ©rios de PromoÃ§Ã£o Entre Ambientes

Cada ambiente (CI â†’ Staging â†’ ProduÃ§Ã£o) precisa provar que estÃ¡ pronto antes de receber a prÃ³xima etapa.

Esses critÃ©rios sÃ£o como â€œregras de promoÃ§Ã£oâ€ dentro do pipeline:

| **Gate** | **CritÃ©rios (Day-03)** | **Ferramentas** | **CD Evolution** |
|----------|----------------|-----------------|------------------|
| **CI** | Cobertura >80%<br/>SAST limpo | Jest, SonarQube | âœ… Foundation |
| **Staging** | Performance p95 <1s<br/>SCA aprovado | Lighthouse, OWASP | ğŸš€ Pre-Prod Validation |
| **Production** | Canary metrics estÃ¡veis<br/>SLOs atendidos | Prometheus, Grafana | ğŸ¯ Live Monitoring |

ğŸ’¡ Perceba como os critÃ©rios evoluem:
no inÃ­cio testamos o cÃ³digo, depois testamos o sistema inteiro, e por fim, monitoramos o comportamento em produÃ§Ã£o.

Ã‰ um ciclo completo de confianÃ§a.

### ğŸ›¡ï¸ Exemplo: Pipeline de Gates Progressivos

Pra visualizar tudo isso na prÃ¡tica, aqui vai um exemplo de pipeline completo com gates desde o CI atÃ© o CD:

```yaml
# .gitlab-ci.yml - Pipeline completo
stages:
  - quality     # Day-03
  - build       # Day-04  
  - deployment  # Day-04

quality_checks:
  stage: quality
  script:
    - npm run test:coverage    # ğŸ‘ˆ Day-03
    - npm run lint             # ğŸ‘ˆ Day-03
    - npm run security:scan    # ğŸ‘ˆ Day-03
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

build_artifact:
  stage: build
  script:
    - docker build -t app:$CI_COMMIT_SHA .
    - echo "$CI_COMMIT_SHA" > version.txt
  needs: ["quality_checks"]

deploy_staging:
  stage: deployment
  script:
    - kubectl apply -f k8s/staging/
    - ./scripts/wait-for-healthy.sh
  needs: ["build_artifact"]
  
deploy_production:
  stage: deployment
  script:
    - kubectl apply -f k8s/production/
  rules:
    - if: $CI_COMMIT_TAG  # ğŸ‘ˆ Deploy manual para produÃ§Ã£o
  needs: ["deploy_staging"]
```

ğŸ’¬ Repara como cada etapa depende da anterior â€” o cÃ³digo sÃ³ Ã© construÃ­do se passar nos testes, e sÃ³ Ã© implantado se tudo estiver saudÃ¡vel.
Ã‰ isso que transforma o pipeline em uma verdadeira linha de produÃ§Ã£o de confianÃ§a.

ğŸ‘‰ Em resumo:
Os gates de qualidade sÃ£o o elo entre o â€œfunciona na minha mÃ¡quinaâ€ e o â€œfunciona em produÃ§Ã£oâ€.
Eles trazem disciplina, visibilidade e seguranÃ§a â€” e fazem a diferenÃ§a entre entregar cÃ³digo e entregar software confiÃ¡vel.


---

## ğŸ§  Caso Real: NHS - AnÃ¡lise com Nossa Stack de Aprendizado

### ğŸ“‹ O Contexto

Em 2023, o NHS (National Health Service), sistema pÃºblico de saÃºde britÃ¢nico, enfrentou uma falha crÃ­tica em seu ambiente de produÃ§Ã£o.
Diversos sistemas ficaram indisponÃ­veis por horas, afetando atendimentos e registros mÃ©dicos.

Vamos reinterpretar esse cenÃ¡rio com o que aprendemos atÃ© o Day-04.

Analisando com nossa lente DevOps:
```bash
# âŒ FALHAS IDENTIFICADAS:
# Day-02: Versionamento semÃ¢ntico inconsistente
# Day-03: Testes de integraÃ§Ã£o insuficientes  
# Day-04: Artefatos nÃ£o-imutÃ¡veis + deploy manual
# Day-04: Monitoramento proativo insuficiente
```

Esses problemas criaram um efeito cascata:

* Releases diferentes foram implantadas com versÃµes ambÃ­guas.
* Faltava automaÃ§Ã£o de validaÃ§Ã£o antes de subir Ã  produÃ§Ã£o.
* O deploy era feito manualmente â€” abrindo margem para erros humanos.
* NÃ£o havia observabilidade contÃ­nua, dificultando a detecÃ§Ã£o precoce de falhas.

ğŸ§© SoluÃ§Ã£o Aplicando Nossa Stack de Aprendizado

Reestruturando o pipeline com base nos conceitos dos Days 02 a 04, temos:

```bash
# âœ… SOLUÃ‡ÃƒO IMPLEMENTADA:

# 1. Day-02: Versionamento confiÃ¡vel e rastreÃ¡vel
VERSION="2.1.0+$(git rev-parse --short HEAD)"

# 2. Day-03: Pipeline de qualidade robusto
# - Testes unitÃ¡rios: 85% cobertura
# - Testes de integraÃ§Ã£o automatizados
# - SAST: 0 vulnerabilidades crÃ­ticas  
# - SCA: dependÃªncias auditadas e atualizadas

# 3. Day-04: CD com artefatos imutÃ¡veis e deploy seguro
# - Artefato: app-${VERSION}.jar (checksum validado)
# - EstratÃ©gia: Canary Release com mÃ©tricas em tempo real
# - Rollback: AutomÃ¡tico se SLOs violados
```

ğŸ’¡ Resultado: o pipeline passou a ser previsÃ­vel, rastreÃ¡vel e resiliente.

Cada versÃ£o Ã© testada, validada e monitorada antes de chegar ao pÃºblico final.

### ğŸ› ï¸ Plano de AÃ§Ã£o NHS Corrigido

```mermaid
flowchart TD
    A[Commit] --> B[CI Rigoroso<br/>Testes + SeguranÃ§a]
    B --> C[Artefato ImutÃ¡vel<br/>Versionado]
    C --> D[Deploy Canary<br/>5% do TrÃ¡fego]
    D --> E[Monitoramento ContÃ­nuo<br/>SLOs em Tempo Real]
    E --> F{SLOs OK?}
    F -->|âœ… SIM| G[Escalonar Gradualmente<br/>25% â†’ 50% â†’ 100%]
    F -->|âŒ NÃƒO| H[Rollback<br/>AutomÃ¡tico e Alerta]
    
    style B fill:#e1f5fe,stroke:#01579b
    style E fill:#fff3e0,stroke:#ff6f00
    style G fill:#e8f5e9,stroke:#2e7d32
    style H fill:#ffebee,stroke:#c62828

```

Esse fluxo representa o ciclo de maturidade do CD:

1. ConfianÃ§a no cÃ³digo (CI).
2. Artefato validado e imutÃ¡vel.
3. Entrega gradual e observÃ¡vel.
4. AutomaÃ§Ã£o na decisÃ£o de avanÃ§o ou rollback.

---

## ğŸ¯ PreparaÃ§Ã£o para o Day-05: Juntando Tudo

### ğŸ§© Nossa Linha do Tempo da Maturidade DevOps

```mermaid
flowchart TD
    A[Day-01<br/>Fundamentos e Cultura] --> B[Day-02<br/>Versionamento e RepositÃ³rios]
    B --> C[Day-03<br/>Qualidade e SeguranÃ§a]
    C --> D[Day-04<br/>Entrega ContÃ­nua e Artefatos]
    D --> E[ğŸš€ Day-05<br/>Pipeline Completo e ObservÃ¡vel]
    
    style E fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
```

A partir do Day-05, vocÃª aprenderÃ¡ a orquestrar tudo isso em uma pipeline Ãºnica, integrando:

* CI + CD automatizados,
* Gates de qualidade dinÃ¢micos,
* Deploy seguro, e
* Observabilidade ativa.

### âœ… Checklist de Aprendizado Day-04

- [x] Compreendo como **artefatos imutÃ¡veis** conectam CI com CD
- [x] Sei diferenciar **Continuous Delivery** vs **Continuous Deployment**
- [x] Consigo escolher entre **Blue-Green** e **Canary** deployments
- [x] Entendo como **gates de qualidade** evoluem do CI para o CD
- [x] ReconheÃ§o a importÃ¢ncia do **monitoramento** no deployment contÃ­nuo
- [x] Consigo aplicar **versionamento semÃ¢ntico** em artefatos
- [x] Compreendo a **progressÃ£o lÃ³gica** entre todos os dias do curso

---

## ğŸ”— Recursos de Apoio

| Tipo | Link | Destaque |
|------|------|----------|
| ğŸ“š Livro | Continuous Delivery - Jez Humble | Fundamentos teÃ³ricos |
| ğŸ› ï¸ Playbook | [Kubernetes Deployment Strategies](https://k8s-deployments.com/) | Exemplos prÃ¡ticos |
| ğŸ¥ VÃ­deo | [Google Cloud - CD vs CD Explained](https://www.youtube.com/watch?v=5y7d6Y2a4b4) | VisualizaÃ§Ã£o clara |
| ğŸ”§ Ferramenta | [Trivy - Container Security](https://aquasecurity.github.io/trivy/) | SeguranÃ§a em artefatos |

---

> **ğŸ’¡ Dica Final:** CI/CD Ã© sobre confianÃ§a.
>
> Cada teste, cada commit organizado, cada artefato versionado Ã© um passo nessa direÃ§Ã£o. AmanhÃ£ vamos ver tudo funcionando junto! ğŸ âœ¨

---

> **ğŸ  Voltar ao Ãndice:** [Ãndice do Curso](home.html)  
> **â¬…ï¸ Anterior:** [Day-03 | Garantia de Qualidade â€” O CoraÃ§Ã£o do CI](03.html)  
> **â¡ï¸ PrÃ³ximo:** [Day-05: Juntando Tudo - Da Teoria Ã  ExcelÃªncia](05.html)
