---
banner_image: media/banner.png
tags: [ci, cd, devops, fundamentos, cicd, artefatos, deployment]
toc: true
extra:
  math: true
  mermaid: true
  mermaid_theme: default
---

# Day-05 | Construindo Pipelines CI/CD - Do Conceito Ã  PrÃ¡tica

---

## ğŸ“Œ O que vocÃª vai aprender hoje

Ao final deste dia, vocÃª vai conseguir:

- Entender cada parte de um pipeline CI/CD
- Saber quando usar testes, builds, scans e deploys
- Aprender a acelerar seus pipelines com cache
- Criar templates para reaproveitar configuraÃ§Ãµes
- Construir pipelines do simples ao avanÃ§ado
- Aplicar boas prÃ¡ticas do mundo real

---

# ğŸ§© Pipeline CI/CD Java - Fluxo Completo com Qualidade

Vamos implementar um pipeline robusto para aplicaÃ§Ã£o Java com todas as etapas de qualidade que vocÃª mencionou.

Perfeito ğŸ‘Œ â€” o seu diagrama estÃ¡ excelente, mas realmente muito denso para visualizaÃ§Ã£o.
A melhor forma de dividir Ã© separar **por nÃ­vel de pipeline** (Dev, MR e Release) e manter um diagrama inicial simples que mostra o fluxo geral.

Aqui vai uma sugestÃ£o didÃ¡tica de **4 blocos Mermaid**, mantendo a clareza visual e a progressÃ£o lÃ³gica:

---

### ğŸ§© 1. Fluxo Geral â€” Do Commit ao Tipo de Pipeline

```mermaid
graph TD
    A[ğŸš€ Commit] --> B[ğŸ”€ Push para Branch]
    B --> C{ğŸ“Œ Tipo de Evento}
    C -->|Branch Dev| D[ğŸ”„ Pipeline Desenvolvimento]
    C -->|Merge Request| E[ğŸ” Pipeline MR]
    C -->|Merge Main| F[ğŸ·ï¸ Pipeline Release]
```

---

### ğŸ’» 2. Pipeline de Desenvolvimento (Branch Dev)

```mermaid
graph TD
    subgraph D [ğŸ”„ Pipeline de Desenvolvimento]
        D1[âœï¸ Lint Commit/MR]
        D2[ğŸ§ª Testes UnitÃ¡rios]
        D3[ğŸ“¦ Build Artifact]
        D4[ğŸ”— Testes de IntegraÃ§Ã£o]
        D5[ğŸ“Š SonarQube]
        D6[ğŸ›¡ï¸ SAST]
        D7[ğŸ“‹ SCA]
        D8[ğŸ³ Scan Docker]
        D9[ğŸ”‘ Scan Secrets]
        D10[ğŸš€ Deploy Snapshot]
        
        D1 --> D2 --> D3 --> D4 --> D5 --> D6 --> D7 --> D8 --> D9 --> D10
    end
```

---

### ğŸ§ª 3. Pipeline de Merge Request (ValidaÃ§Ã£o de Qualidade)

```mermaid
graph TD
    subgraph E [ğŸ” Pipeline de Merge Request]
        E1[âœï¸ Lint Commit/MR]
        E2[ğŸ§ª Testes UnitÃ¡rios]
        E3[ğŸ“¦ Build Artifact]
        E4[ğŸ”— Testes de IntegraÃ§Ã£o]
        E5[ğŸ“Š SonarQube]
        E6[ğŸ›¡ï¸ SAST]
        E7[ğŸ“‹ SCA]
        E8[ğŸ³ Scan Docker]
        E9[ğŸ”‘ Scan Secrets]
        E10[ğŸš€ Deploy Review]
        
        E1 --> E2 --> E3 --> E4 --> E5 --> E6 --> E7 --> E8 --> E9 --> E10
    end
```

---

### ğŸš€ 4. Pipeline de Release (Entrega e ProduÃ§Ã£o)

```mermaid
graph TD
    subgraph F [ğŸ·ï¸ Pipeline de Release]
        F1[ğŸ·ï¸ Create Tag]
        F2[ğŸ“¦ Build Release]
        F3[ğŸ¯ Quality Gate]
        F4[ğŸš€ Deploy Staging]
        F5[ğŸ¤– Testes E2E]
        F6[ğŸ‘‘ Deploy Production]
        
        F1 --> F2 --> F3 --> F4 --> F5 --> F6
    end
```

## ğŸ³ **Imagem Customizada OpenJDK**

Vamos usar uma imagem customizada com todas as ferramentas necessÃ¡rias:

**Dockerfile.ci**
```dockerfile
FROM openjdk:17-jdk-slim

# InstalaÃ§Ãµes bÃ¡sicas
RUN apt-get update && apt-get install -y \
    curl \
    gnupg \
    git \
    python3 \
    python3-pip \
    && rm -rf /var/lib/apt/lists/*

# Instala Maven
ARG MAVEN_VERSION=3.9.6
RUN curl -fsSL https://archive.apache.org/dist/maven/maven-3/${MAVEN_VERSION}/binaries/apache-maven-${MAVEN_VERSION}-bin.tar.gz | \
    tar -xzf - -C /opt && \
    ln -s /opt/apache-maven-${MAVEN_VERSION} /opt/maven && \
    ln -s /opt/maven/bin/mvn /usr/bin/mvn

# Instala Node.js para commitlint
RUN curl -fsSL https://deb.nodesource.com/setup_18.x | bash - && \
    apt-get install -y nodejs

# Instala ferramentas de seguranÃ§a
RUN curl -sfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin && \
    curl -sfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin

# Instala gitleaks
RUN curl -sfL https://github.com/gitleaks/gitleaks/releases/latest/download/gitleaks_$(uname -s)_$(uname -m).tar.gz | \
    tar -xzf - -C /usr/local/bin

# Instala trivy
RUN curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin

# Configura environment
ENV JAVA_HOME=/usr/local/openjdk-17
ENV M2_HOME=/opt/maven
ENV PATH="$M2_HOME/bin:$PATH"

WORKDIR /workspace
```

## ğŸ”§ **Pipeline Principal (.gitlab-ci.yml)**

```yaml
image: registry.company.com/ci/java-maven:latest

variables:
  MAVEN_OPTS: "-Dmaven.repo.local=.m2/repository -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=WARN"
  MAVEN_CLI_OPTS: "--batch-mode --errors --fail-at-end --show-version"

stages:
  - validation
  - test
  - build
  - quality
  - deployment
  - release

# Cache para melhor performance
cache:
  key: "${CI_COMMIT_REF_SLUG}"
  paths:
    - .m2/repository
    - target/
```

## âœï¸ **ValidaÃ§Ã£o Inicial**

```yaml
lint_commits:
  stage: validation
  image: node:18-alpine
  before_script:
    - npm install -g @commitlint/cli @commitlint/config-conventional
  script:
    - |
      cat << EOF > .commitlintrc.json
      {
        "extends": ["@commitlint/config-conventional"],
        "rules": {
          "type-enum": [2, "always", [
            "feat", "fix", "docs", "style", "refactor",
            "test", "chore", "perf", "ci", "build", "revert"
          ]],
          "scope-enum": [2, "always", [
            "controller", "service", "repository", "model",
            "config", "security", "test", "deps", "maven", "api"
          ]]
        }
      }
      EOF
    - echo "$CI_COMMIT_MESSAGE" | npx commitlint
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - if: $CI_COMMIT_BRANCH

lint_mr_title:
  stage: validation
  image: node:18-alpine
  before_script:
    - npm install -g @commitlint/cli @commitlint/config-conventional
  script:
    - echo "$CI_MERGE_REQUEST_TITLE" | npx commitlint
  rules:
    - if: $CI_MERGE_REQUEST_IID
```

## ğŸ§ª **Testes**

```yaml
unit_tests:
  stage: test
  script:
    - mvn $MAVEN_CLI_OPTS clean test
    - mvn $MAVEN_CLI_OPTS jacoco:report
  artifacts:
    paths:
      - target/site/jacoco/
    reports:
      junit:
        - target/surefire-reports/*.xml
    expire_in: 1 week
  coverage: '/Total.*?([0-9]{1,3})%/'
  rules:
    - if: $CI_COMMIT_BRANCH

integration_tests:
  stage: test
  script:
    - mvn $MAVEN_CLI_OPTS verify -DskipUnitTests
    - mvn $MAVEN_CLI_OPTS failsafe:report
  artifacts:
    paths:
      - target/site/failsafe-reports/
    reports:
      junit:
        - target/failsafe-reports/*.xml
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH
```

## ğŸ“¦ **Build**

```yaml
build_artifact:
  stage: build
  script:
    - mvn $MAVEN_CLI_OPTS clean package -DskipTests
    - |
      if [[ "$CI_COMMIT_BRANCH" == "$CI_DEFAULT_BRANCH" ]]; then
        mvn $MAVEN_CLI_OPTS versions:set -DnewVersion=${CI_COMMIT_TAG:-$CI_COMMIT_SHORT_SHA}
      else
        mvn $MAVEN_CLI_OPTS versions:set -DnewVersion=${CI_COMMIT_SHORT_SHA}-SNAPSHOT
      fi
  artifacts:
    paths:
      - target/*.jar
      - target/*.war
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH

build_docker:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  script:
    - |
      if [[ "$CI_COMMIT_BRANCH" == "$CI_DEFAULT_BRANCH" && -n "$CI_COMMIT_TAG" ]]; then
        export IMAGE_TAG=$CI_COMMIT_TAG
      else
        export IMAGE_TAG=$CI_COMMIT_SHORT_SHA-SNAPSHOT
      fi
    - docker build -t $CI_REGISTRY_IMAGE:$IMAGE_TAG .
    - docker push $CI_REGISTRY_IMAGE:$IMAGE_TAG
  rules:
    - if: $CI_COMMIT_BRANCH
```

## ğŸ›¡ï¸ **Qualidade - Security & SAST**

```yaml
code_quality:
  stage: quality
  script:
    - mvn $MAVEN_CLI_OPTS sonar:sonar 
        -Dsonar.projectKey=my-java-app 
        -Dsonar.host.url=$SONAR_HOST_URL 
        -Dsonar.login=$SONAR_TOKEN
        -Dsonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml
  rules:
    - if: $CI_COMMIT_BRANCH

sast_analysis:
  stage: quality
  script:
    - mvn $MAVEN_CLI_OPTS org.owasp:dependency-check-maven:check
    - mvn $MAVEN_CLI_OPTS pmd:check
    - mvn $MAVEN_CLI_OPTS spotless:check
    - mvn $MAVEN_CLI_OPTS checkstyle:check
  artifacts:
    paths:
      - target/dependency-check-report.html
      - target/pmd.xml
      - target/checkstyle-result.xml
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH

sca_analysis:
  stage: quality
  script:
    - mvn $MAVEN_CLI_OPTS versions:display-dependency-updates
    - mvn $MAVEN_CLI_OPTS org.owasp:dependency-check-maven:aggregate
  artifacts:
    reports:
      dependency_scanning:
        - target/dependency-check-report.json
  rules:
    - if: $CI_COMMIT_BRANCH

docker_scan:
  stage: quality
  script:
    - |
      if [[ "$CI_COMMIT_BRANCH" == "$CI_DEFAULT_BRANCH" && -n "$CI_COMMIT_TAG" ]]; then
        export IMAGE_TAG=$CI_COMMIT_TAG
      else
        export IMAGE_TAG=$CI_COMMIT_SHORT_SHA-SNAPSHOT
      fi
    - trivy image --exit-code 1 --severity HIGH,CRITICAL $CI_REGISTRY_IMAGE:$IMAGE_TAG
    - trivy image --format template --template "@contrib/html.tpl" -o gl-dependency-scanning-report.html $CI_REGISTRY_IMAGE:$IMAGE_TAG
  artifacts:
    reports:
      container_scanning:
        - gl-dependency-scanning-report.html
  rules:
    - if: $CI_COMMIT_BRANCH

secret_scan:
  stage: quality
  script:
    - gitleaks detect --source . --verbose --redact
  rules:
    - if: $CI_COMMIT_BRANCH
```

## ğŸš€ **Deploy por Ambiente**

```yaml
deploy_dev_snapshot:
  stage: deployment
  image: bitnami/kubectl:latest
  script:
    - |
      if [[ "$CI_COMMIT_BRANCH" != "$CI_DEFAULT_BRANCH" ]]; then
        echo "Deploying SNAPSHOT version to Dev"
        kubectl set image deployment/myapp myapp=$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA-SNAPSHOT -n dev
        kubectl rollout status deployment/myapp -n dev --timeout=300s
      fi
  environment:
    name: dev
    url: https://dev.myapp.com
  when: manual
  rules:
    - if: $CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH

deploy_qa_review:
  stage: deployment
  image: bitnami/kubectl:latest
  script:
    - echo "Deploying MR version to QA for review"
    - kubectl set image deployment/myapp-review-$CI_MERGE_REQUEST_IID myapp=$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA-SNAPSHOT -n qa
    - kubectl rollout status deployment/myapp-review-$CI_MERGE_REQUEST_IID -n qa --timeout=300s
  environment:
    name: qa/review
    url: https://review-${CI_MERGE_REQUEST_IID}.qa.myapp.com
    on_stop: stop_qa_review
  when: manual
  rules:
    - if: $CI_MERGE_REQUEST_IID

stop_qa_review:
  stage: deployment
  image: bitnami/kubectl:latest
  script:
    - kubectl delete deployment/myapp-review-$CI_MERGE_REQUEST_IID -n qa
  when: manual
  environment:
    name: qa/review
    action: stop
  rules:
    - if: $CI_MERGE_REQUEST_IID
```

## ğŸ·ï¸ **Release & Production**

```yaml
create_release:
  stage: release
  image: registry.company.com/ci/java-maven:latest
  before_script:
    - git config --global user.email "ci@company.com"
    - git config --global user.name "CI/CD Bot"
  script:
    - |
      # Analisa commits para determinar versionamento
      LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
      echo "Latest tag: $LATEST_TAG"
      
      # Determina prÃ³ximo version baseado nos commits desde Ãºltimo tag
      if git log --oneline $LATEST_TAG..HEAD | grep -q "feat:"; then
        BUMP="minor"
      elif git log --oneline $LATEST_TAG..HEAD | grep -q "fix:"; then
        BUMP="patch"
      else
        BUMP="patch"
      fi
      
      # Calcula nova versÃ£o
      VERSION=$(echo $LATEST_TAG | sed 's/^v//')
      MAJOR=$(echo $VERSION | cut -d. -f1)
      MINOR=$(echo $VERSION | cut -d. -f2)
      PATCH=$(echo $VERSION | cut -d. -f3)
      
      case $BUMP in
        "major") NEW_VERSION="v$((MAJOR+1)).0.0" ;;
        "minor") NEW_VERSION="v$MAJOR.$((MINOR+1)).0" ;;
        "patch") NEW_VERSION="v$MAJOR.$MINOR.$((PATCH+1))" ;;
      esac
      
      echo "New version: $NEW_VERSION"
      
      # Cria tag e release
      git tag -a $NEW_VERSION -m "Release $NEW_VERSION"
      git push origin $NEW_VERSION
      
      # Atualiza POM com nova versÃ£o
      mvn versions:set -DnewVersion=$NEW_VERSION -DgenerateBackupPups=false
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual

deploy_staging:
  stage: deployment
  image: bitnami/kubectl:latest
  script:
    - echo "Deploying release $CI_COMMIT_TAG to Staging"
    - kubectl set image deployment/myapp myapp=$CI_REGISTRY_IMAGE:$CI_COMMIT_TAG -n staging
    - kubectl rollout status deployment/myapp -n staging --timeout=300s
  environment:
    name: staging
    url: https://staging.myapp.com
  rules:
    - if: $CI_COMMIT_TAG

e2e_tests:
  stage: deployment
  image: cypress/included:12.0.0
  script:
    - npm install
    - npx cypress run --config baseUrl=https://staging.myapp.com
  rules:
    - if: $CI_COMMIT_TAG

deploy_production:
  stage: deployment
  image: bitnami/kubectl:latest
  script:
    - echo "Deploying release $CI_COMMIT_TAG to Production"
    - kubectl set image deployment/myapp myapp=$CI_REGISTRY_IMAGE:$CI_COMMIT_TAG -n production
    - kubectl rollout status deployment/myapp -n production --timeout=600s
  environment:
    name: production
    url: https://myapp.com
  when: manual
  rules:
    - if: $CI_COMMIT_TAG
```

## ğŸ“Š **Workflows EspecÃ­ficos**

```yaml
# Pipeline para desenvolvimento em branches
.development_rules: &development_rules
  rules:
    - if: $CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH && $CI_PIPELINE_SOURCE == "push"

# Pipeline para Merge Requests
.mr_rules: &mr_rules
  rules:
    - if: $CI_MERGE_REQUEST_IID

# Pipeline para main branch
.main_rules: &main_rules
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH && $CI_PIPELINE_SOURCE == "push"

# Aplica regras especÃ­ficas
unit_tests:
  rules:
    - *development_rules
    - *mr_rules
    - *main_rules

integration_tests:
  rules:
    - *development_rules
    - *mr_rules
    - *main_rules

code_quality:
  rules:
    - *mr_rules
    - *main_rules

deploy_dev_snapshot:
  rules:
    - *development_rules
```

## ğŸ¯ **Resumo do Fluxo**

```mermaid
sequenceDiagram
    participant D as Developer
    participant G as GitLab
    participant CI as CI Pipeline
    participant K as Kubernetes
    participant S as SonarQube
    
    Note over D, S: ğŸš€ Fluxo Desenvolvimento
    D->>G: git push feature-branch
    G->>CI: Trigger pipeline
    CI->>CI: âœï¸ Lint Commit
    CI->>CI: ğŸ§ª Unit & Integration Tests
    CI->>CI: ğŸ“¦ Build Snapshot Artifact
    CI->>S: ğŸ“Š SonarQube Analysis
    CI->>CI: ğŸ›¡ï¸ SAST/SCA/Security Scans
    CI->>D: âœ… Pipeline Passed
    D->>G: Cria Merge Request
    G->>CI: Trigger MR Pipeline
    CI->>CI: ğŸ” Quality Gates
    CI->>K: ğŸš€ Deploy Review App (Manual)
    D->>G: Merge para main
    G->>CI: Trigger Release Pipeline
    CI->>CI: ğŸ·ï¸ Create Semantic Version
    CI->>K: ğŸš€ Deploy Staging (Auto)
    CI->>CI: ğŸ¤– Run E2E Tests
    CI->>D: ğŸ“ Approve Production
    D->>CI: ğŸ‘‘ Approve Deployment
    CI->>K: ğŸ¯ Deploy Production (Manual)
```

Este pipeline oferece:
- âœ… **ValidaÃ§Ã£o rigorosa** de commits e cÃ³digo
- ğŸ›¡ï¸ **MÃºltiplas camadas** de seguranÃ§a (SAST, SCA, container scan)
- ğŸ“Š **Quality gates** com SonarQube
- ğŸ·ï¸ **Versionamento semÃ¢ntico** automÃ¡tico
- ğŸš€ **Deploys progressivos** por ambiente
- ğŸ”„ **Fluxos separados** para dev, MR e release

---

# âš¡ Acelerando Seus Pipelines Java: EstratÃ©gias PrÃ¡ticas para Ganhar Tempo

## ğŸ¢ **O Problema: "Minha Pipeline EstÃ¡ Muito Lenta!"**

**JÃ¡ se pegou pensando...**
- "Toda vez baixo as mesmas dependÃªncias do Maven?"
- "Por que demora tanto sÃ³ para comeÃ§ar os testes?"
- "SerÃ¡ que preciso reinstalar tudo a cada execuÃ§Ã£o?"

**VocÃª nÃ£o estÃ¡ sozinho!** Esse Ã© um dos maiores gargalos em pipelines Java. Mas a boa notÃ­cia Ã© que tem soluÃ§Ã£o!

---

## ğŸ—ƒï¸ **Cache Inteligente: Seu Melhor Amigo na Velocidade**

### ğŸ¤” **O que Ã© Cache?**
Pense no cache como uma **"mala de ferramentas"** que vocÃª prepara uma vez e reaproveita sempre. Em vez de comprar novas ferramentas todo dia, vocÃª sÃ³ troca o que realmente quebrou.

### ğŸš€ **ImplementaÃ§Ã£o PrÃ¡tica**

```yaml
# ANTES (Como fazer compras toda vez ğŸ˜´)
build_java:
  script:
    - mvn clean package   # Baixa o mundo todo... de novo

# DEPOIS (Como ter sua prÃ³pria oficina ğŸ› ï¸)
cache:
  key: "maven-${CI_COMMIT_REF_SLUG}"  # ArmÃ¡rio com seu nome
  paths:
    - .m2/repository/     # Suas ferramentas organizadas
    - target/             # PeÃ§as que jÃ¡ montou
  policy: pull-push       # "Pego minhas ferramentas e depois guardo"

build_java:
  cache:
    policy: pull          # "Vou pegar minhas ferramentas do armÃ¡rio"
  script:
    - mvn clean package -Dmaven.repo.local=.m2/repository
```

### ğŸ“Š **Resultado que VocÃª Vai Ver:**
```
SEM cache: 5-10 minutos ğŸ˜´
COM cache: 1-2 minutos ğŸš€
```

**Ganho real:** AtÃ© 80% mais rÃ¡pido!

---

## ğŸ¯ **Cache EstratÃ©gico: Organizando Sua Oficina**

### ğŸ·ï¸ **Cache por Tipo de Projeto**
```yaml
# Para projeto Spring Boot
cache:
  key: "spring-${CI_COMMIT_REF_SLUG}"
  paths:
    - .m2/repository/
    - target/spring-boot-app/

# Para projeto Micronaut  
cache:
  key: "micronaut-${CI_COMMIT_REF_SLUG}"
  paths:
    - .m2/repository/
    - target/micronaut-app/
```

### ğŸ”„ **Cache Inteligente para DependÃªncias**
```yaml
# "Ah, mas e se mudar as dependÃªncias?"
cache_pom_dependencies:
  cache:
    key: "deps-${CI_COMMIT_SHA}"  # Chave Ãºnica quando POM muda
    paths:
      - .m2/repository/
    policy: push
  script:
    - mvn dependency:resolve
  only:
    changes:
      - pom.xml  # SÃ³ roda quando dependÃªncias mudam
```

---

## ğŸ“¦ **Imagens Customizadas: Sua "Van de ServiÃ§o" Pronta**

### ğŸ¤” **A Analogia:**
Imagine que toda manhÃ£ vocÃª:
- Compra uma van nova
- Instala todas as ferramentas
- Organiza tudo no porta-malas
- SÃ³ entÃ£o comeÃ§a a trabaljar

**Ã‰ exatamente isso que fazemos sem imagem customizada!**

### ğŸ› ï¸ **SoluÃ§Ã£o: Sua Van Personalizada**
```dockerfile
# Dockerfile.java-ci - Sua van com tudo organizado
FROM openjdk:17-jdk-slim

# Suas ferramentas favoritas jÃ¡ instaladas:
RUN apt-get update && apt-get install -y curl git

# Maven - sua chave de fenda principal
RUN curl -fsSL https://archive.apache.org/dist/maven/maven-3/3.9.6/binaries/apache-maven-3.9.6-bin.tar.gz | tar -xzf - -C /opt

# Scanner de seguranÃ§a - seu detector de problemas
RUN curl -sfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin

# Tudo configurado e pronto!
ENV PATH="/opt/apache-maven-3.9.6/bin:${PATH}"
WORKDIR /workspace
```

### ğŸš€ **Usando no Pipeline:**
```yaml
image: registry.suaempresa.com/ci/java-toolbox:latest

build_rapido:
  script:
    - mvn clean package  # âš¡ Tudo jÃ¡ estÃ¡ na van!
```

### ğŸ“Š **Impacto no Tempo:**
```
SEM imagem customizada: 3-5 minutos de preparaÃ§Ã£o
COM imagem customizada: 30-60 segundos ğŸš€
```

## ğŸª **ParalelizaÃ§Ã£o: Trabalhando como uma Equipe**

### ğŸ¤” **O Problema do "Faz Tudo":**
Imagine um mecÃ¢nico que:
1. Troca pneus
2. Faz alinhamento
3. Troca Ã³leo
4. Limpa o carro
5. Faz revisÃ£o elÃ©trica

**Tudo sozinho, uma coisa por vez!** Demora horrores!

### ğŸ‘¥ **SoluÃ§Ã£o: A Equipe de MecÃ¢nicos**
```yaml
# SEQUENCIAL (Um faz-tudo â³)
mecanico_geral:
  script:
    - mvn checkstyle:check    # Primeira tarefa
    - mvn pmd:check           # Espera a anterior...
    - mvn test                # Espera...
    - mvn spotbugs:check      # Espera...

# PARALELO (Equipe especializada ğŸš€)
equipe_qualidade:
  stage: quality
  parallel:  # Todos trabalham JUNTOS!
    - script: mvn checkstyle:check  # Especialista em estilo
    - script: mvn pmd:check         # Especialista em padrÃµes  
    - script: mvn spotbugs:check    # Especialista em bugs

equipe_testes:
  stage: test
  parallel:
    - script: mvn test              # Testador unitÃ¡rio
    - script: mvn verify -DskipUnitTests  # Testador integraÃ§Ã£o
```

### ğŸ“Š **Ganho de Tempo:**
```
1 pessoa fazendo tudo: 15 minutos
4 pessoas especializadas: 5 minutos ğŸš€
```

## ğŸ”§ **TÃ©cnicas AvanÃ§adas de OtimizaÃ§Ã£o**

### ğŸš€ **Build Incremental: SÃ³ Mexe no que Mudou**
```yaml
build_esperto:
  script:
    # SÃ³ recompila classes modificadas
    - mvn compile -Dmaven.main.skip=true
    # SÃ³ testa o que pode ter quebrado
    - mvn test -Dtest="**/*Test" -DfailIfNoTests=false
```

### ğŸ“¦ **Modo Offline: Trabalhe sem Internet**
```yaml
preparar_dependencias:
  script:
    - mvn dependency:go-offline  # "FaÃ§a compras para a semana toda"

trabalhar_offline:
  script:
    - mvn package -o  # âš¡ Trabalhe sem precisar da internet!
  dependencies:
    - preparar_dependencias
```

## ğŸ¯ **Plano de AÃ§Ã£o: Comece Hoje!**

### ğŸ¥‡ **Passo 1 - Implemente Cache (5 minutos)**
```yaml
# Adicione isso no seu .gitlab-ci.yml
cache:
  key: "${CI_COMMIT_REF_SLUG}"
  paths:
    - .m2/repository/
```

### ğŸ¥ˆ **Passo 2 - Paralelize o Ã“bvio (10 minutos)**
```yaml
# Separe testes de verificaÃ§Ãµes de qualidade
# Eles nÃ£o dependem um do outro!
```

### ğŸ¥‰ **Passo 3 - Crie Sua Imagem (30 minutos)**
```dockerfile
# Dockerfile simples para comeÃ§ar
FROM openjdk:17-jdk-slim
RUN apt-get update && apt-get install -y maven
```


## ğŸ“ˆ **Painel de Resultados Esperados**

| TÃ©cnica | Antes | Depois | Ganho |
|---------|-------|---------|-------|
| **Cache Maven** | ğŸ¢ 5-10 min | ğŸš€ 1-2 min | â­ 80% |
| **Imagem Custom** | ğŸ¢ 3-5 min | ğŸš€ 30-60s | â­ 90% |
| **ParalelizaÃ§Ã£o** | ğŸ¢ 15 min | ğŸš€ 5 min | â­ 70% |
| **Build Incremental** | ğŸ¢ 8 min | ğŸš€ 2 min | â­ 75% |

---

## ğŸ’¡ **Dica Final do Especialista**

**"NÃ£o tente otimizar tudo de uma vez!"**

Comece pelo cache - Ã© o que dÃ¡ mais resultado com menos esforÃ§o. Depois evolua para paralelizaÃ§Ã£o e por Ãºltimo crie suas imagens customizadas.

**Lembre-se:** Uma pipeline 2x mais rÃ¡pida significa:
- Desenvolvedores 2x mais produtivos
- Feedback 2x mais rÃ¡pido
- Entregas 2x mais frequentes

**Qual tÃ©cnica vocÃª vai implementar primeiro?** ğŸš€

---

## ğŸ¨ Templates - Evite RepetiÃ§Ã£o

**Problema:** "Copio e colo a mesma configuraÃ§Ã£o em todos os projetos!"

**SoluÃ§Ã£o:** Templates reutilizÃ¡veis

### ğŸ“ Criando um Template de SeguranÃ§a

```yaml
# templates/seguranca.yml
.verificacao_seguranca: &seguranca
  stage: seguranca
  script:
    - npm audit --audit-level high
    - npx snyk test
  allow_failure: false

verificar_dependencias:
  <<: *seguranca
  image: node:18

verificar_container:
  <<: *seguranca  
  image: trivy:latest
  script:
    - trivy image $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
```

### ğŸ”§ Usando o Template

```yaml
# No seu projeto:
include:
  - project: 'devops/templates'
    file: '/templates/seguranca.yml'

# Agora vocÃª tem todos os jobs de seguranÃ§a!
# Sem copiar e colar! ğŸ‰
```

---

# ğŸ—ï¸ Templates de Pipeline: ReutilizaÃ§Ã£o Inteligente de CÃ³digo CI/CD

## ğŸ¤” **O que sÃ£o Templates e Por que UsÃ¡-los?**

### ğŸ“š **A Analogia do Livro de Receitas**

Pense nos templates como **receitas de famÃ­lia** que vocÃª jÃ¡ testou e sabe que funcionam. Em vez de reinventar a roda todo vez, vocÃª reaproveita o conhecimento que jÃ¡ deu certo!

**Sem templates:**
```yaml
# Time A - Projeto Frontend
testar_frontend:
  script:
    - npm install
    - npm run test
    - npm run lint

# Time B - Outro Frontend  
testar_app:
  script:
    - npm ci
    - npm test
    - npm run lint:check
```

**Problema:** Cada time "reinventa" a mesma coisa, com pequenas variaÃ§Ãµes que causam inconsistÃªncias.

**Com templates:**
```yaml
# Template centralizado
.testar_frontend: &testar_frontend
  script:
    - npm ci
    - npm run test
    - npm run lint

# Times usando o template
# Time A:
testar_app:
  <<: *testar_frontend

# Time B:
validar_codigo:
  <<: *testar_frontend
```

**Vantagem:** PadronizaÃ§Ã£o, manutenÃ§Ã£o centralizada, consistÃªncia!

---

## ğŸ¯ **Quando Usar Templates?**

### âœ… **Use Templates Quando:**
- **MÃºltiplos projetos** fazem coisas similares
- **VÃ¡rios times** precisam do mesmo fluxo
- **Quer garantir padrÃµes** de qualidade
- **Precisa escalar** prÃ¡ticas de DevOps
- **Quer reduzir duplicaÃ§Ã£o** de cÃ³digo

### âŒ **Evite Templates Quando:**
- Projeto Ãºnico e especÃ­fico
- Fluxo muito customizado
- Time pequeno sem necessidade de padronizaÃ§Ã£o

---

## ğŸ—ï¸ **Tipos de Templates no GitLab CI**

### 1. **Templates Locais (YAML Anchors)**
**Ideal para:** Reuso dentro do mesmo arquivo

```yaml
# ğŸ”§ DefiniÃ§Ã£o do template
.testar_java_template: &testar_java
  image: openjdk:17
  cache:
    paths:
      - .m2/repository/
  before_script:
    - mvn dependency:resolve

# ğŸš€ Uso do template
testes_unitarios:
  <<: *testar_java_template  # ğŸ” Reuso aqui!
  script:
    - mvn test

testes_integracao:
  <<: *testar_java_template  # ğŸ” E aqui tambÃ©m!
  script:
    - mvn verify -DskipUnitTests
```

### 2. **Templates com ParÃ¢metros**
**Ideal para:** Templates flexÃ­veis que precisam de customizaÃ§Ã£o

```yaml
# ğŸ›ï¸ Template configurÃ¡vel
.testar_com_cobertura: &testar_com_cobertura
  script:
    - mvn test
    - mvn jacoco:report
  artifacts:
    paths:
      - target/site/jacoco/
    reports:
      coverage_report:
        coverage_format: cobertura
        path: target/site/jacoco/jacoco.xml
  coverage: '/Total.*?([0-9]{1,3})%/'

# ğŸ¯ Uso com customizaÃ§Ã£o
testes_backend:
  <<: *testar_com_cobertura
  variables:
    COVERAGE_THRESHOLD: "80%"

testes_frontend:
  <<: *testar_com_cobertura  
  variables:
    COVERAGE_THRESHOLD: "70%"
```

### 3. **Templates Externos (Includes)**
**Ideal para:** Compartilhamento entre mÃºltiplos projetos

```yaml
# ğŸ“ .gitlab-ci.yml (no seu projeto)
include:
  - project: 'devops/ci-templates'
    file: '/templates/java-ci.yml'
  - project: 'devops/ci-templates'
    file: '/templates/security-scan.yml'
  - project: 'devops/ci-templates'  
    file: '/templates/k8s-deploy.yml'

# ğŸš€ Seu pipeline fica limpo!
stages:
  - test
  - security
  - deploy

testes_java:
  extends: .java_tests

verificar_seguranca:
  extends: .security_scan

deploy_kubernetes:
  extends: .k8s_deploy
  variables:
    ENVIRONMENT: "staging"
```

---

## ğŸ› ï¸ **Criando Templates Eficientes**

### ğŸ“ **Template de Qualidade Java**
```yaml
# templates/java-quality.yml
.quality_checks: &quality_checks
  stage: quality
  image: openjdk:17
  cache:
    key: "quality-${CI_COMMIT_REF_SLUG}"
    paths:
      - .m2/repository/
  before_script:
    - mvn dependency:resolve -Dmaven.repo.local=.m2/repository

.checkstyle_template: &checkstyle
  <<: *quality_checks
  script:
    - mvn checkstyle:check
  allow_failure: false

.pmd_template: &pmd  
  <<: *quality_checks
  script:
    - mvn pmd:check
  allow_failure: true

.spotbugs_template: &spotbugs
  <<: *quality_checks
  script:
    - mvn spotbugs:check
  artifacts:
    paths:
      - target/spotbugs.xml

# Template composto
.java_quality_gate:
  <<: *quality_checks
  parallel:
    matrix:
      - JOB: [checkstyle, pmd, spotbugs]
  script:
    - case $JOB in
        "checkstyle") mvn checkstyle:check ;;
        "pmd") mvn pmd:check ;;
        "spotbugs") mvn spotbugs:check ;;
      esac
```

### ğŸ”’ **Template de SeguranÃ§a**
```yaml
# templates/security.yml
.security_scan: &security_scan
  stage: security
  image: registry.company.com/security-scanners:latest
  before_script:
    - export SCAN_DATE=$(date +%Y-%m-%d)

.dependency_scan: &dependency_scan
  <<: *security_scan
  script:
    - mvn org.owasp:dependency-check-maven:check
    - trivy fs . --severity HIGH,CRITICAL
  artifacts:
    reports:
      dependency_scanning: target/dependency-check-report.html

.secrets_scan: &secrets_scan  
  <<: *security_scan
  script:
    - gitleaks detect --source . --verbose --redact
  rules:
    - if: $CI_COMMIT_BRANCH

.container_scan: &container_scan
  <<: *security_scan
  script:
    - trivy image $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
```

---

## ğŸ¯ **Exemplos PrÃ¡ticos de Uso**

### ğŸ“¦ **Pipeline com Templates para MicroserviÃ§o Java**
```yaml
include:
  - project: 'devops/ci-templates'
    file: '/java/microservice-pipeline.yml'

variables:
  MAVEN_OPTS: "-Dmaven.repo.local=.m2/repository"
  SERVICE_NAME: "user-service"

stages:
  - validate
  - test
  - quality
  - security
  - build
  - deploy

# ğŸ” Reuso inteligente
validate_code:
  extends: .java_validation
  variables:
    CHECKSTYLE_CONFIG: "config/checkstyle.xml"

unit_tests:
  extends: .java_unit_tests
  parallel: 3

integration_tests:
  extends: .java_integration_tests

quality_gate:
  extends: .java_quality_checks

security_scan:
  extends: .security_scan_full

build_image:
  extends: .java_docker_build
  variables:
    DOCKERFILE_PATH: "Dockerfile.jre"

deploy_staging:
  extends: .k8s_deploy
  variables:
    ENVIRONMENT: "staging"
    NAMESPACE: "microservices"
```

### ğŸŒ **Template para AplicaÃ§Ã£o Web Full Stack**
```yaml
# templates/fullstack-pipeline.yml
.fullstack_backend: &backend_template
  image: openjdk:17
  cache:
    key: "backend-${CI_COMMIT_REF_SLUG}"
    paths:
      - .m2/repository/
      - target/

.fullstack_frontend: &frontend_template  
  image: node:18
  cache:
    key: "frontend-${CI_COMMIT_REF_SLUG}"
    paths:
      - node_modules/
      - .next/cache/

.fullstack_quality: &quality_template
  stage: quality
  script:
    - echo "Running quality checks for fullstack app"
  dependencies: []

# ğŸ­ Uso em pipeline real
include:
  - project: 'devops/ci-templates'
    file: '/templates/fullstack-pipeline.yml'

backend_tests:
  <<: *backend_template
  stage: test
  script:
    - mvn test

frontend_tests:
  <<: *frontend_template
  stage: test  
  script:
    - npm ci
    - npm run test
    - npm run build

fullstack_quality:
  <<: *quality_template
  needs:
    - backend_tests
    - frontend_tests
```

---

## ğŸš€ **Vantagens dos Templates**

### âœ… **Para Desenvolvedores:**
```yaml
# ANTES: Escrever tudo manualmente
meu_job_complicado:
  stage: test
  image: openjdk:17
  cache: 
    key: "complex-${CI_COMMIT_REF_SLUG}"
    paths: [.m2/repository/]
  before_script: [mvn dependency:resolve]
  script: [mvn test, mvn jacoco:report]
  artifacts: {paths: [target/site/jacoco/]}
  # ... mais 20 linhas ...

# DEPOIS: Usar template
meu_job_simples:
  extends: .java_test_with_coverage
```

### âœ… **Para DevOps/Platform:**
- **PadronizaÃ§Ã£o** entre todos os times
- **ManutenÃ§Ã£o centralizada** - corrige um, corrige todos
- **GovernanÃ§a** - controle sobre prÃ¡ticas de CI/CD
- **Onboarding rÃ¡pido** - novos projetos em minutos

### âœ… **Para a Empresa:**
- **ReduÃ§Ã£o de duplicaÃ§Ã£o** - menos cÃ³digo para manter
- **ConsistÃªncia** - mesma qualidade em todos os projetos
- **Escalabilidade** - novos times replicam boas prÃ¡ticas rapidamente

---

## ğŸ”§ **Melhores PrÃ¡ticas na CriaÃ§Ã£o de Templates**

### 1. **FaÃ§a Templates ConfigurÃ¡veis**
```yaml
.java_build_template: &java_build
  image: ${JAVA_IMAGE:-openjdk:17}
  cache:
    key: "${CACHE_KEY:-default}"
    paths:
      - .m2/repository/
  script:
    - mvn clean package ${MAVEN_ARGS:--DskipTests}
```

### 2. **Documente Seus Templates**
```yaml
# templates/README.md
## Java Test Template (.java_test_template)

### VariÃ¡veis suportadas:
- JAVA_IMAGE: Imagem Docker (padrÃ£o: openjdk:17)
- TEST_ARGS: Argumentos para Maven (padrÃ£o: -DskipITs)
- COVERAGE: Gerar relatÃ³rio JaCoCo? (padrÃ£o: true)

### Uso:
```yaml
meus_testes:
  extends: .java_test_template
  variables:
    TEST_ARGS: "-Dtest=User*Test"
```

### 3. **Versionamento de Templates**
```yaml
include:
  - project: 'devops/ci-templates'
    ref: 'v2.1.0'  # ğŸ“Œ VersÃ£o especÃ­fica!
    file: '/java/quality-checks.yml'
```

---

## ğŸ“ˆ **EvoluÃ§Ã£o: Do BÃ¡sico ao AvanÃ§ado**

### ğŸ‘¶ **Fase 1: Templates Locais**
```yaml
# Comece pequeno - no mesmo arquivo
.test_template: &test
  image: openjdk:17
  script: mvn test

unit_tests:
  <<: *test

integration_tests:  
  <<: *test
  script: mvn verify -DskipUnitTests
```

### ğŸ§‘â€ğŸ’» **Fase 2: Templates Externos Simples**
```yaml
# Separe em arquivos reutilizÃ¡veis
include:
  - local: '/templates/java-tests.yml'
  - local: '/templates/security.yml'
```

### ğŸ¢ **Fase 3: Templates Corporativos**
```yaml
# Templates centralizados na organizaÃ§Ã£o
include:
  - project: 'org/ci-templates'
    ref: 'v3.0.0'
    file: '/pipelines/microservice-java.yml'
  
  - component: 'gitlab.com/org/security-scans@1.0.0'
  
  - template: 'Security/SAST.gitlab-ci.yml'
```

---

## ğŸ¯ **Comece Hoje Mesmo!**

### ğŸ¥‡ **Passo 1: Identifique PadrÃµes**
Olhe seus pipelines atuais - o que se repete?

### ğŸ¥ˆ **Passo 2: Crie Seu Primeiro Template**
```yaml
# No seu .gitlab-ci.yml
.testar_java: &testar_java
  image: openjdk:17
  cache:
    paths: [.m2/repository/]
  script: mvn test

# Use o template
testes_servico_a:
  <<: *testar_java

testes_servico_b:
  <<: *testar_java
```

### ğŸ¥‰ **Passo 3: Evolua Gradualmente**
- Semana 1: Templates locais
- Semana 2: Templates com parÃ¢metros  
- Semana 3: Templates externos
- Semana 4: Templates organizacionais

**Lembre-se:** O objetivo nÃ£o Ã© complexidade, mas **simplicidade atravÃ©s da reutilizaÃ§Ã£o inteligente!** ğŸš€

---

# ğŸ›¡ï¸ Boas PrÃ¡ticas Essenciais para Pipelines que Realmente Funcionam

## âœ… **Seu Checklist de Sucesso**

### ğŸ¯ **FaÃ§a Isso Sempre (NÃ£o Pule Nenhum!):**

1. **âš¡ Fail Fast - Erre RÃ¡pido, Corrija Mais RÃ¡pido Ainda**
```yaml
# ORDEM INTELIGENTE: descubra problemas baratos primeiro
stages:
  - validacao       # âš¡ Segundos - validaÃ§Ãµes bÃ¡sicas
  - testes_rapidos  # âš¡ Minutos - testes unitÃ¡rios
  - qualidade       # âš¡ Minutos - anÃ¡lise estÃ¡tica
  - seguranca       # âš¡ Minutos - scans de seguranÃ§a
  - testes_lentos   # ğŸ• Horas - testes integraÃ§Ã£o/E2E
  - build           # ğŸ• ConstrÃ³i sÃ³ se tudo passar
  - deploy          # ğŸš€ Entrega sÃ³ o que foi validado
```

2. **ğŸ—ƒï¸ Cache EstratÃ©gico - Seu Atalho para a Velocidade**
```yaml
cache:
  key: "${CI_COMMIT_REF_SLUG}-${CI_JOB_NAME}"
  paths:
    - .m2/repository/           # âš¡ DependÃªncias Maven/Java
    - node_modules/             # âš¡ DependÃªncias Node.js
    - target/                   # âš¡ Artefatos compilados
    - .gradle/caches/           # âš¡ Cache Gradle
    - .sonar/cache/             # âš¡ Cache SonarQube
  policy: pull-push             # ğŸ“¦ Pega e devolve ao cache
```

3. **ğŸ—ï¸ Templates - NÃ£o Escreva o Mesmo CÃ³digo 10 Vezes**
```yaml
# ğŸ“š Biblioteca de templates da organizaÃ§Ã£o
include:
  - project: 'devops/ci-templates'
    file: '/security/owasp-scan.yml'
  - project: 'devops/ci-templates'
    file: '/quality/sonarqube-analysis.yml'
  - project: 'devops/ci-templates'
    file: '/deploy/kubernetes-rollout.yml'

# ğŸš€ Pipeline limpo e consistente
code_quality:
  extends: .sonarqube_analysis

security_scan:
  extends: .owasp_dependency_check

production_deploy:
  extends: .k8s_blue_green
```

4. **ğŸ‘‘ Deploy Manual para ProduÃ§Ã£o - O BotÃ£o que Salva Vidas**
```yaml
deploy_production:
  stage: deploy
  environment: production
  script:
    - kubectl rollout restart deployment/myapp
  when: manual                    # ğŸ”’ AprovaÃ§Ã£o humana obrigatÃ³ria
  only:
    - tags                       # ğŸ·ï¸ SÃ³ versÃµes oficialmente lanÃ§adas
  rules:
    - if: $CI_COMMIT_TAG && $DEPLOY_TO_PROD == "true"
```

5. **ğŸ“Š Feedback VisÃ­vel - Mostre o que EstÃ¡ Acontecendo**
```yaml
notify_teams:
  stage: .post
  script:
    - |
      if [ "$CI_JOB_STATUS" == "success" ]; then
        curl -X POST -H "Content-Type: application/json" \
        -d "{\"text\":\"âœ… Pipeline ${CI_PIPELINE_ID} passou! Deploy pronto para ${CI_ENVIRONMENT_NAME}\"}" \
        $TEAMS_WEBHOOK
      else
        curl -X POST -H "Content-Type: application/json" \
        -d "{\"text\":\"âŒ Pipeline ${CI_PIPELINE_ID} falhou no job ${CI_JOB_NAME}. Verifique ASAP!\"}" \
        $TEAMS_WEBHOOK
      fi
```

---

## âŒ **Armadilhas que VocÃª Precisa Evitar:**

### 1. **ğŸ” Credenciais no CÃ³digo - O Erro que Custa Caro**
```yaml
# âŒ NUNCA FAÃ‡A ISSO:
deploy:
  script:
    - kubectl config set-credentials user --token=MEU_TOKEN_SUPER_SECRETO  # ğŸ˜±
    - docker login -u meuusuario -p minhasenha                           # ğŸ˜±

# âœ… FAÃ‡A ASSIM:
deploy:
  script:
    - echo $KUBECONFIG_BASE64 | base64 -d > ~/.kube/config              # ğŸ”’
    - echo $DOCKER_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin
  variables:
    KUBECONFIG_BASE64: $PRODUCTION_KUBECONFIG  # âš ï¸ VariÃ¡vel protegida no GitLab
```

### 2. **ğŸ™ Pipelines Gigantes - O Monstro que NinguÃ©m MantÃ©m**
```yaml
# âŒ Pipeline monolÃ­tico impossÃ­vel de manter
um_job_gigante:
  script:
    - mvn clean test checkstyle:check pmd:check spotbugs:check 
    - mvn sonar:sonar dependency:check
    - mvn package docker:build 
    - kubectl apply -f k8s/
    # ... mais 50 comandos ...

# âœ… Pipeline modular e compreensÃ­vel
# stages separadas, jobs focados, templates organizados
```

### 3. **ğŸ”„ Sem Rollback - Apostar Tudo no "Vai Dar Certo"**
```yaml
# âŒ SÃ³ tem ida, nÃ£o tem volta
deploy_production:
  script: kubectl apply -f deployment.yaml

# âœ… Plano B sempre pronto  
deploy_production:
  script:
    - kubectl apply -f deployment.yaml
    - kubectl rollout status deployment/myapp --timeout=300s

rollback_production:
  script: kubectl rollout undo deployment/myapp
  when: manual
  environment: production
```

### 4. **ğŸ›¡ï¸ Ignorar SeguranÃ§a - Convite para Problemas**
```yaml
# âŒ Pipeline "cego" para seguranÃ§a
build_and_deploy:
  script:
    - mvn package
    - docker build .
    - kubectl apply -f k8s/

# âœ… Pipeline com "visÃ£o" de seguranÃ§a
stages:
  - security_scan
  - quality_gate
  - build
  - deploy

security_scan:
  script:
    - trivy fs . --exit-code 1
    - gitleaks detect --source . -v
    - mvn org.owasp:dependency-check:check
```

---

## ğŸ¯ **Resumo da Sua Jornada de Aprendizado**

### ğŸ§  **O que VocÃª Domina Agora:**

| Habilidade | NÃ­vel | Impacto |
|------------|-------|---------|
| **ğŸ§© Arquitetura de Pipeline** | âœ… AvanÃ§ado | Pipeline bem estruturado |
| **âš¡ OtimizaÃ§Ã£o de Performance** | âœ… AvanÃ§ado | 80% mais rÃ¡pido com cache |
| **ğŸ—ï¸ Templates e ReutilizaÃ§Ã£o** | âœ… IntermediÃ¡rio | ManutenÃ§Ã£o 5x mais fÃ¡cil |
| **ğŸ” SeguranÃ§a Integrada** | âœ… IntermediÃ¡rio | DetecÃ§Ã£o proativa de riscos |
| **ğŸš€ Deploy ConfiÃ¡vel** | âœ… BÃ¡sico-AvanÃ§ado | Entrega segura e reversÃ­vel |

### ğŸ“ˆ **Seu Progresso na Escala de Maturidade:**

```
FASE 1: Iniciante ğŸŸ¢
âœ“ Pipeline bÃ¡sico funcionando
âœ“ Testes automatizados
âœ“ Deploy manual

FASE 2: IntermediÃ¡rio ğŸŸ¡  
âœ“ Cache estratÃ©gico
âœ“ Templates bÃ¡sicos
âœ“ Scans de seguranÃ§a
âœ“ Deploy em staging

FASE 3: AvanÃ§ado ğŸ”´
âœ“ Pipeline como cÃ³digo
âœ“ Templates corporativos
âœ“ Deploy automatizado com aprovaÃ§Ã£o
âœ“ Monitoramento e mÃ©tricas
```

---

## ğŸš€ **PrÃ³ximos Passos na Sua Jornada**

### ğŸ¥‡ **Semana 1: FundaÃ§Ã£o SÃ³lida**
```yaml
# Sua missÃ£o: Pipeline mÃ­nimo viÃ¡vel
objectivos:
  - [x] Pipeline bÃ¡sico com testes
  - [ ] Cache de dependÃªncias implementado
  - [ ] Deploy para ambiente de desenvolvimento
  - [ ] NotificaÃ§Ãµes no Teams/Slack
```

### ğŸ¥ˆ **Semana 2-3: Ganhando Velocidade**
```yaml
# Sua missÃ£o: OtimizaÃ§Ã£o e qualidade
metas:
  - [ ] Tempo de build reduzido em 50%
  - [ ] Scans de seguranÃ§a OWASP implementados
  - [ ] Quality gate com SonarQube
  - [ ] Pipeline paralelizado
```

### ğŸ¥‰ **Semana 4: ExcelÃªncia Operacional**
```yaml
# Sua missÃ£o: Confiabilidade empresarial
objetivos_avancados:
  - [ ] Templates reutilizÃ¡veis criados
  - [ ] Deploy blue-green em produÃ§Ã£o
  - [ ] Rollback automÃ¡tico configurado
  - [ ] MÃ©tricas de qualidade coletadas
```

---

## âœ… **Checklist Final do que VocÃª Consegue Fazer**

### ğŸ¯ **Habilidades Concretas Adquiridas:**

- [ ] **Projetar** a arquitetura de um pipeline do zero
- [ ] **Otimizar** performance com cache e paralelizaÃ§Ã£o
- [ ] **Implementar** verificaÃ§Ãµes de seguranÃ§a automatizadas
- [ ] **Criar** templates para reutilizaÃ§Ã£o entre projetos
- [ ] **Configurar** deploy progressivo entre ambientes
- [ ] **Monitorar** qualidade e performance do pipeline
- [ ] **Troubleshoot** problemas comuns em CI/CD
- [ ] **Evoluir** pipelines simples para enterprise-grade

### ğŸ› ï¸ **Ferramentas no Seu Belt:**
- GitLab CI/CD âœ“
- Docker & Kubernetes âœ“  
- Maven/Gradle âœ“
- SonarQube âœ“
- Trivy & OWASP âœ“
- Cache estratÃ©gico âœ“
- Templates YAML âœ“

---

## ğŸ† **Seu Kit de SobrevivÃªncia para CI/CD**

**ğŸ“š DocumentaÃ§Ã£o de ReferÃªncia RÃ¡pida:**
```yaml
# Estrutura bÃ¡sica que sempre funciona
image: appropriate-runtime

cache:
  key: "${CI_COMMIT_REF_SLUG}"
  paths: [dependencies-folder]

stages:
  - validate    # âš¡ RÃ¡pido
  - test        # âš¡ RÃ¡pido  
  - security    # ğŸ›¡ï¸ Essencial
  - build       # ğŸ“¦ NecessÃ¡rio
  - deploy      # ğŸš€ Controlado

# Fail fast, cache smart, secure always
```

**ğŸ¯ PrincÃ­pios que NÃ£o Falham:**
1. **Erre rÃ¡pido** - testes rÃ¡pidos primeiro
2. **Reuse sempre** - templates e cache
3. **SeguranÃ§a primeiro** - scans automÃ¡ticos
4. **Controle humano** - aprovaÃ§Ã£o para produÃ§Ã£o
5. **Melhoria contÃ­nua** - meÃ§a e otimize

---

## ğŸŒŸ **Palavras Finais do Mentor**

> **"O pipeline perfeito nÃ£o Ã© aquele que tem mais features, mas o que entrega valor com confiabilidade e velocidade."**

**ğŸ‰ ParabÃ©ns!** VocÃª evoluiu de "o que Ã© CI/CD?" para "como escalo CI/CD para enterprise!" 

**Lembre-se:**
- Comece **simples** - um pipeline que funciona Ã© melhor que um perfeito que nÃ£o existe
- Otimize **gradualmente** - cache primeiro, depois paralelizaÃ§Ã£o, depois templates
- SeguranÃ§a **sempre** - nÃ£o Ã© feature, Ã© requisito
- Humanos no **controle** - automaÃ§Ã£o sim, mas com supervisÃ£o humana

**ğŸ“ PrÃ³xima Parada:** PrÃ¡tica real! Pegue seu projeto atual e aplique pelo menos 3 coisas que aprendeu hoje.

---

**ğŸ  Voltar ao Ãndice:** [Ãndice do Curso](home.html)  
**â¬…ï¸ Aula Anterior:** [Day-04 | Do CI ao CD - Artefatos, Entrega e Deploy ContÃ­nuo](04.html)  
**ğŸ“š PrÃ³ximos Passos:** [Mini Curso de Jenkins](https://github.com/waltenne/jenkins_course/tree/doc/jenkins)

**ğŸš€ "Um deploy por dia mantÃ©m o stress longe!"** - Agora vocÃª tem o poder de entregar valor frequentemente e com confianÃ§a!